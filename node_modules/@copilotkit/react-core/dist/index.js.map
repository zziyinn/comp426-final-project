{"version":3,"sources":["../src/index.tsx","../src/components/copilot-provider/copilotkit.tsx","../src/context/copilot-context.tsx","../src/hooks/use-tree.ts","../src/hooks/use-flat-category-store.ts","../src/components/copilot-provider/copilot-messages.tsx","../src/context/copilot-messages-context.tsx","../src/hooks/use-copilot-chat.ts","../src/hooks/use-chat.ts","../src/hooks/use-copilot-action.ts","../src/hooks/use-coagent-state-render.ts","../src/hooks/use-make-copilot-document-readable.ts","../src/hooks/use-copilot-readable.ts","../src/hooks/use-coagent.ts","../src/lib/copilot-task.ts","../src/utils/extract.ts"],"sourcesContent":["\"use client\";\nexport * from \"./components\";\nexport * from \"./context\";\nexport * from \"./hooks\";\nexport * from \"./types\";\nexport * from \"./lib\";\nexport * from \"./utils\";\n","/**\n * This component will typically wrap your entire application (or a sub-tree of your application where you want to have a copilot). It provides the copilot context to all other components and hooks.\n *\n * ## Example\n *\n * You can find more information about self-hosting CopilotKit [here](/guides/self-hosting).\n *\n * ```tsx\n * import { CopilotKit } from \"@copilotkit/react-core\";\n *\n * <CopilotKit runtimeUrl=\"<your-runtime-url>\">\n *   // ... your app ...\n * </CopilotKit>\n * ```\n */\n\nimport { useCallback, useMemo, useRef, useState } from \"react\";\nimport {\n  CopilotContext,\n  CopilotApiConfig,\n  ChatComponentsCache,\n  AgentSession,\n} from \"../../context/copilot-context\";\nimport useTree from \"../../hooks/use-tree\";\nimport { CopilotChatSuggestionConfiguration, DocumentPointer } from \"../../types\";\nimport { flushSync } from \"react-dom\";\nimport {\n  COPILOT_CLOUD_CHAT_URL,\n  CopilotCloudConfig,\n  FunctionCallHandler,\n} from \"@copilotkit/shared\";\n\nimport { FrontendAction } from \"../../types/frontend-action\";\nimport useFlatCategoryStore from \"../../hooks/use-flat-category-store\";\nimport { CopilotKitProps } from \"./copilotkit-props\";\nimport { CoAgentStateRender } from \"../../types/coagent-action\";\nimport { CoagentState } from \"../../types/coagent-state\";\nimport { CopilotMessages } from \"./copilot-messages\";\n\nexport function CopilotKit({ children, ...props }: CopilotKitProps) {\n  // Compute all the functions and properties that we need to pass\n  // to the CopilotContext.\n\n  if (!props.runtimeUrl && !props.publicApiKey) {\n    throw new Error(\n      \"Please provide either a runtimeUrl or a publicApiKey to the CopilotKit component.\",\n    );\n  }\n\n  const chatApiEndpoint = props.runtimeUrl || COPILOT_CLOUD_CHAT_URL;\n\n  const [actions, setActions] = useState<Record<string, FrontendAction<any>>>({});\n  const [coAgentStateRenders, setCoAgentStateRenders] = useState<\n    Record<string, CoAgentStateRender<any>>\n  >({});\n  const chatComponentsCache = useRef<ChatComponentsCache>({\n    actions: {},\n    coAgentStateRenders: {},\n  });\n  const { addElement, removeElement, printTree } = useTree();\n  const [isLoading, setIsLoading] = useState(false);\n  const [chatInstructions, setChatInstructions] = useState(\"\");\n\n  const {\n    addElement: addDocument,\n    removeElement: removeDocument,\n    allElements: allDocuments,\n  } = useFlatCategoryStore<DocumentPointer>();\n\n  const setAction = useCallback((id: string, action: FrontendAction<any>) => {\n    setActions((prevPoints) => {\n      return {\n        ...prevPoints,\n        [id]: action,\n      };\n    });\n  }, []);\n\n  const removeAction = useCallback((id: string) => {\n    setActions((prevPoints) => {\n      const newPoints = { ...prevPoints };\n      delete newPoints[id];\n      return newPoints;\n    });\n  }, []);\n\n  const setCoAgentStateRender = useCallback((id: string, stateRender: CoAgentStateRender<any>) => {\n    setCoAgentStateRenders((prevPoints) => {\n      return {\n        ...prevPoints,\n        [id]: stateRender,\n      };\n    });\n  }, []);\n\n  const removeCoAgentStateRender = useCallback((id: string) => {\n    setCoAgentStateRenders((prevPoints) => {\n      const newPoints = { ...prevPoints };\n      delete newPoints[id];\n      return newPoints;\n    });\n  }, []);\n\n  const getContextString = useCallback(\n    (documents: DocumentPointer[], categories: string[]) => {\n      const documentsString = documents\n        .map((document) => {\n          return `${document.name} (${document.sourceApplication}):\\n${document.getContents()}`;\n        })\n        .join(\"\\n\\n\");\n\n      const nonDocumentStrings = printTree(categories);\n\n      return `${documentsString}\\n\\n${nonDocumentStrings}`;\n    },\n    [printTree],\n  );\n\n  const addContext = useCallback(\n    (\n      context: string,\n      parentId?: string,\n      categories: string[] = defaultCopilotContextCategories,\n    ) => {\n      return addElement(context, categories, parentId);\n    },\n    [addElement],\n  );\n\n  const removeContext = useCallback(\n    (id: string) => {\n      removeElement(id);\n    },\n    [removeElement],\n  );\n\n  const getFunctionCallHandler = useCallback(\n    (customEntryPoints?: Record<string, FrontendAction<any>>) => {\n      return entryPointsToFunctionCallHandler(Object.values(customEntryPoints || actions));\n    },\n    [actions],\n  );\n\n  const getDocumentsContext = useCallback(\n    (categories: string[]) => {\n      return allDocuments(categories);\n    },\n    [allDocuments],\n  );\n\n  const addDocumentContext = useCallback(\n    (documentPointer: DocumentPointer, categories: string[] = defaultCopilotContextCategories) => {\n      return addDocument(documentPointer, categories);\n    },\n    [addDocument],\n  );\n\n  const removeDocumentContext = useCallback(\n    (documentId: string) => {\n      removeDocument(documentId);\n    },\n    [removeDocument],\n  );\n\n  if (!props.publicApiKey) {\n    if (props.cloudRestrictToTopic) {\n      throw new Error(\n        \"To use the cloudRestrictToTopic feature, please sign up at https://copilotkit.ai and provide a publicApiKey.\",\n      );\n    }\n  }\n\n  // get the appropriate CopilotApiConfig from the props\n  const copilotApiConfig: CopilotApiConfig = useMemo(() => {\n    let cloud: CopilotCloudConfig | undefined = undefined;\n    if (props.publicApiKey) {\n      cloud = {\n        guardrails: {\n          input: {\n            restrictToTopic: {\n              enabled: props.cloudRestrictToTopic ? true : false,\n              validTopics: props.cloudRestrictToTopic?.validTopics || [],\n              invalidTopics: props.cloudRestrictToTopic?.invalidTopics || [],\n            },\n          },\n        },\n      };\n    }\n\n    return {\n      publicApiKey: props.publicApiKey,\n      ...(cloud ? { cloud } : {}),\n      chatApiEndpoint: chatApiEndpoint,\n      headers: props.headers || {},\n      properties: props.properties || {},\n      transcribeAudioUrl: props.transcribeAudioUrl,\n      textToSpeechUrl: props.textToSpeechUrl,\n      credentials: props.credentials,\n    };\n  }, [\n    props.publicApiKey,\n    props.headers,\n    props.properties,\n    props.transcribeAudioUrl,\n    props.textToSpeechUrl,\n    props.credentials,\n    props.cloudRestrictToTopic,\n  ]);\n\n  const [chatSuggestionConfiguration, setChatSuggestionConfiguration] = useState<{\n    [key: string]: CopilotChatSuggestionConfiguration;\n  }>({});\n\n  const addChatSuggestionConfiguration = (\n    id: string,\n    suggestion: CopilotChatSuggestionConfiguration,\n  ) => {\n    setChatSuggestionConfiguration((prev) => ({ ...prev, [id]: suggestion }));\n  };\n\n  const removeChatSuggestionConfiguration = (id: string) => {\n    setChatSuggestionConfiguration((prev) => {\n      const { [id]: _, ...rest } = prev;\n      return rest;\n    });\n  };\n\n  const [coagentStates, setCoagentStates] = useState<Record<string, CoagentState>>({});\n  let initialAgentSession: AgentSession | null = null;\n  if (props.agent) {\n    initialAgentSession = {\n      agentName: props.agent,\n    };\n  }\n\n  const [agentSession, setAgentSession] = useState<AgentSession | null>(initialAgentSession);\n\n  return (\n    <CopilotContext.Provider\n      value={{\n        actions,\n        chatComponentsCache,\n        getFunctionCallHandler,\n        setAction,\n        removeAction,\n        coAgentStateRenders,\n        setCoAgentStateRender,\n        removeCoAgentStateRender,\n        getContextString,\n        addContext,\n        removeContext,\n        getDocumentsContext,\n        addDocumentContext,\n        removeDocumentContext,\n        copilotApiConfig: copilotApiConfig,\n        isLoading,\n        setIsLoading,\n        chatSuggestionConfiguration,\n        addChatSuggestionConfiguration,\n        removeChatSuggestionConfiguration,\n        chatInstructions,\n        setChatInstructions,\n        showDevConsole: props.showDevConsole === undefined ? \"auto\" : props.showDevConsole,\n        coagentStates,\n        setCoagentStates,\n        agentSession,\n        setAgentSession,\n      }}\n    >\n      <CopilotMessages>{children}</CopilotMessages>\n    </CopilotContext.Provider>\n  );\n}\n\nexport const defaultCopilotContextCategories = [\"global\"];\n\nfunction entryPointsToFunctionCallHandler(actions: FrontendAction<any>[]): FunctionCallHandler {\n  return async ({ messages, name, args }) => {\n    let actionsByFunctionName: Record<string, FrontendAction<any>> = {};\n    for (let action of actions) {\n      actionsByFunctionName[action.name] = action;\n    }\n\n    const action = actionsByFunctionName[name];\n    let result: any = undefined;\n    if (action) {\n      await new Promise<void>((resolve, reject) => {\n        flushSync(async () => {\n          try {\n            result = await action.handler?.(args);\n            resolve();\n          } catch (error) {\n            reject(error);\n          }\n        });\n      });\n      await new Promise((resolve) => setTimeout(resolve, 20));\n    }\n    return result;\n  };\n}\n","import { CopilotCloudConfig, FunctionCallHandler } from \"@copilotkit/shared\";\nimport { ActionRenderProps, FrontendAction } from \"../types/frontend-action\";\nimport React from \"react\";\nimport { TreeNodeId } from \"../hooks/use-tree\";\nimport { DocumentPointer } from \"../types\";\nimport { CopilotChatSuggestionConfiguration } from \"../types/chat-suggestion-configuration\";\nimport { CoAgentStateRender, CoAgentStateRenderProps } from \"../types/coagent-action\";\nimport { CoagentState } from \"../types/coagent-state\";\n\n/**\n * Interface for the configuration of the Copilot API.\n */\nexport interface CopilotApiConfig {\n  /**\n   * The public API key for Copilot Cloud.\n   */\n  publicApiKey?: string;\n\n  /**\n   * The configuration for Copilot Cloud.\n   */\n  cloud?: CopilotCloudConfig;\n\n  /**\n   * The endpoint for the chat API.\n   */\n  chatApiEndpoint: string;\n\n  /**\n   * The endpoint for the Copilot transcribe audio service.\n   */\n  transcribeAudioUrl?: string;\n\n  /**\n   * The endpoint for the Copilot text to speech service.\n   */\n  textToSpeechUrl?: string;\n\n  /**\n   * additional headers to be sent with the request\n   * @default {}\n   * @example\n   * ```\n   * {\n   *   'Authorization': 'Bearer your_token_here'\n   * }\n   * ```\n   */\n  headers: Record<string, string>;\n\n  /**\n   * Custom properties to be sent with the request\n   * @default {}\n   * @example\n   * ```\n   * {\n   *   'user_id': 'user_id'\n   * }\n   * ```\n   */\n  properties?: Record<string, any>;\n\n  /**\n   * Indicates whether the user agent should send or receive cookies from the other domain\n   * in the case of cross-origin requests.\n   */\n  credentials?: RequestCredentials;\n}\n\nexport type InChatRenderFunction = (props: ActionRenderProps<any>) => string | JSX.Element;\nexport type CoagentInChatRenderFunction = (\n  props: CoAgentStateRenderProps<any>,\n) => string | JSX.Element | undefined | null;\n\nexport interface ChatComponentsCache {\n  actions: Record<string, InChatRenderFunction | string>;\n  coAgentStateRenders: Record<string, CoagentInChatRenderFunction | string>;\n}\n\nexport interface AgentSession {\n  agentName: string;\n  threadId?: string;\n  nodeName?: string;\n}\n\nexport interface CopilotContextParams {\n  // function-calling\n  actions: Record<string, FrontendAction<any>>;\n  setAction: (id: string, action: FrontendAction<any>) => void;\n  removeAction: (id: string) => void;\n\n  // coagent actions\n  coAgentStateRenders: Record<string, CoAgentStateRender<any>>;\n  setCoAgentStateRender: (id: string, stateRender: CoAgentStateRender<any>) => void;\n  removeCoAgentStateRender: (id: string) => void;\n\n  chatComponentsCache: React.RefObject<ChatComponentsCache>;\n\n  getFunctionCallHandler: (\n    customEntryPoints?: Record<string, FrontendAction<any>>,\n  ) => FunctionCallHandler;\n\n  // text context\n  addContext: (context: string, parentId?: string, categories?: string[]) => TreeNodeId;\n  removeContext: (id: TreeNodeId) => void;\n  getContextString: (documents: DocumentPointer[], categories: string[]) => string;\n\n  // document context\n  addDocumentContext: (documentPointer: DocumentPointer, categories?: string[]) => TreeNodeId;\n  removeDocumentContext: (documentId: string) => void;\n  getDocumentsContext: (categories: string[]) => DocumentPointer[];\n\n  isLoading: boolean;\n  setIsLoading: React.Dispatch<React.SetStateAction<boolean>>;\n\n  chatSuggestionConfiguration: { [key: string]: CopilotChatSuggestionConfiguration };\n  addChatSuggestionConfiguration: (\n    id: string,\n    suggestion: CopilotChatSuggestionConfiguration,\n  ) => void;\n  removeChatSuggestionConfiguration: (id: string) => void;\n\n  chatInstructions: string;\n  setChatInstructions: React.Dispatch<React.SetStateAction<string>>;\n\n  // api endpoints\n  copilotApiConfig: CopilotApiConfig;\n\n  showDevConsole: boolean | \"auto\";\n\n  // agents\n  coagentStates: Record<string, CoagentState>;\n  setCoagentStates: React.Dispatch<React.SetStateAction<Record<string, CoagentState>>>;\n  agentSession: AgentSession | null;\n  setAgentSession: React.Dispatch<React.SetStateAction<AgentSession | null>>;\n}\n\nconst emptyCopilotContext: CopilotContextParams = {\n  actions: {},\n  setAction: () => {},\n  removeAction: () => {},\n\n  coAgentStateRenders: {},\n  setCoAgentStateRender: () => {},\n  removeCoAgentStateRender: () => {},\n\n  chatComponentsCache: { current: { actions: {}, coAgentStateRenders: {} } },\n  getContextString: (documents: DocumentPointer[], categories: string[]) =>\n    returnAndThrowInDebug(\"\"),\n  addContext: () => \"\",\n  removeContext: () => {},\n\n  getFunctionCallHandler: () => returnAndThrowInDebug(async () => {}),\n\n  isLoading: false,\n  setIsLoading: () => returnAndThrowInDebug(false),\n\n  chatInstructions: \"\",\n  setChatInstructions: () => returnAndThrowInDebug(\"\"),\n\n  getDocumentsContext: (categories: string[]) => returnAndThrowInDebug([]),\n  addDocumentContext: () => returnAndThrowInDebug(\"\"),\n  removeDocumentContext: () => {},\n\n  copilotApiConfig: new (class implements CopilotApiConfig {\n    get chatApiEndpoint(): string {\n      throw new Error(\"Remember to wrap your app in a `<CopilotKit> {...} </CopilotKit>` !!!\");\n    }\n\n    get headers(): Record<string, string> {\n      return {};\n    }\n    get body(): Record<string, any> {\n      return {};\n    }\n  })(),\n\n  chatSuggestionConfiguration: {},\n  addChatSuggestionConfiguration: () => {},\n  removeChatSuggestionConfiguration: () => {},\n  showDevConsole: \"auto\",\n  coagentStates: {},\n  setCoagentStates: () => {},\n\n  agentSession: null,\n  setAgentSession: () => {},\n};\n\nexport const CopilotContext = React.createContext<CopilotContextParams>(emptyCopilotContext);\n\nexport function useCopilotContext(): CopilotContextParams {\n  const context = React.useContext(CopilotContext);\n  if (context === emptyCopilotContext) {\n    throw new Error(\"Remember to wrap your app in a `<CopilotKit> {...} </CopilotKit>` !!!\");\n  }\n  return context;\n}\n\nfunction returnAndThrowInDebug<T>(value: T): T {\n  throw new Error(\"Remember to wrap your app in a `<CopilotKit> {...} </CopilotKit>` !!!\");\n  return value;\n}\n","import { randomId } from \"@copilotkit/shared\";\nimport { useCallback, useReducer } from \"react\";\n\nexport type TreeNodeId = string;\n\nexport interface TreeNode {\n  id: TreeNodeId;\n  value: string;\n  children: TreeNode[];\n  parentId?: TreeNodeId;\n  categories: Set<string>;\n}\n\nexport type Tree = TreeNode[];\n\nexport interface UseTreeReturn {\n  tree: Tree;\n  addElement: (value: string, categories: string[], parentId?: TreeNodeId) => TreeNodeId;\n  printTree: (categories: string[]) => string;\n  removeElement: (id: TreeNodeId) => void;\n}\n\nconst findNode = (nodes: Tree, id: TreeNodeId): TreeNode | undefined => {\n  for (const node of nodes) {\n    if (node.id === id) {\n      return node;\n    }\n    const result = findNode(node.children, id);\n    if (result) {\n      return result;\n    }\n  }\n  return undefined;\n};\n\nconst removeNode = (nodes: Tree, id: TreeNodeId): Tree => {\n  return nodes.reduce((result: Tree, node) => {\n    if (node.id !== id) {\n      const newNode = { ...node, children: removeNode(node.children, id) };\n      result.push(newNode);\n    }\n    return result;\n  }, []);\n};\n\nconst addNode = (nodes: Tree, newNode: TreeNode, parentId?: TreeNodeId): Tree => {\n  if (!parentId) {\n    return [...nodes, newNode];\n  }\n  return nodes.map((node) => {\n    if (node.id === parentId) {\n      return { ...node, children: [...node.children, newNode] };\n    } else if (node.children.length) {\n      return { ...node, children: addNode(node.children, newNode, parentId) };\n    }\n    return node;\n  });\n};\n\nconst treeIndentationRepresentation = (index: number, indentLevel: number): string => {\n  if (indentLevel === 0) {\n    return (index + 1).toString();\n  } else if (indentLevel === 1) {\n    return String.fromCharCode(65 + index); // 65 is the ASCII value for 'A'\n  } else if (indentLevel === 2) {\n    return String.fromCharCode(97 + index); // 97 is the ASCII value for 'a'\n  } else {\n    return \"-\";\n  }\n};\n\nconst printNode = (node: TreeNode, prefix = \"\", indentLevel = 0): string => {\n  const indent = \" \".repeat(3).repeat(indentLevel);\n\n  const prefixPlusIndentLength = prefix.length + indent.length;\n  const subsequentLinesPrefix = \" \".repeat(prefixPlusIndentLength);\n\n  const valueLines = node.value.split(\"\\n\");\n\n  const outputFirstLine = `${indent}${prefix}${valueLines[0]}`;\n  const outputSubsequentLines = valueLines\n    .slice(1)\n    .map((line) => `${subsequentLinesPrefix}${line}`)\n    .join(\"\\n\");\n\n  let output = `${outputFirstLine}\\n`;\n  if (outputSubsequentLines) {\n    output += `${outputSubsequentLines}\\n`;\n  }\n\n  const childPrePrefix = \" \".repeat(prefix.length);\n\n  node.children.forEach(\n    (child, index) =>\n      (output += printNode(\n        child,\n        `${childPrePrefix}${treeIndentationRepresentation(index, indentLevel + 1)}. `,\n        indentLevel + 1,\n      )),\n  );\n  return output;\n};\n\n// Action types\ntype Action =\n  | {\n      type: \"ADD_NODE\";\n      value: string;\n      parentId?: string;\n      id: string;\n      categories: string[];\n    }\n  | { type: \"REMOVE_NODE\"; id: string };\n\n// Reducer function\nfunction treeReducer(state: Tree, action: Action): Tree {\n  switch (action.type) {\n    case \"ADD_NODE\": {\n      const { value, parentId, id: newNodeId } = action;\n      const newNode: TreeNode = {\n        id: newNodeId,\n        value,\n        children: [],\n        categories: new Set(action.categories),\n      };\n\n      try {\n        return addNode(state, newNode, parentId);\n      } catch (error) {\n        console.error(`Error while adding node with id ${newNodeId}: ${error}`);\n        return state;\n      }\n    }\n    case \"REMOVE_NODE\":\n      return removeNode(state, action.id);\n    default:\n      return state;\n  }\n}\n\n// useTree hook\nconst useTree = (): UseTreeReturn => {\n  const [tree, dispatch] = useReducer(treeReducer, []);\n\n  const addElement = useCallback(\n    (value: string, categories: string[], parentId?: string): TreeNodeId => {\n      const newNodeId = randomId(); // Generate new ID outside of dispatch\n      dispatch({\n        type: \"ADD_NODE\",\n        value,\n        parentId,\n        id: newNodeId,\n        categories: categories,\n      });\n      return newNodeId; // Return the new ID\n    },\n    [],\n  );\n\n  const removeElement = useCallback((id: TreeNodeId): void => {\n    dispatch({ type: \"REMOVE_NODE\", id });\n  }, []);\n\n  const printTree = useCallback(\n    (categories: string[]): string => {\n      const categoriesSet = new Set(categories);\n\n      let output = \"\";\n      tree.forEach((node, index) => {\n        // if the node does not have any of the desired categories, continue to the next node\n        if (!setsHaveIntersection(categoriesSet, node.categories)) {\n          return;\n        }\n\n        // add a new line before each node except the first one\n        if (index !== 0) {\n          output += \"\\n\";\n        }\n\n        output += printNode(node, `${treeIndentationRepresentation(index, 0)}. `);\n      });\n      return output;\n    },\n    [tree],\n  );\n\n  return { tree, addElement, printTree, removeElement };\n};\n\nexport default useTree;\n\nfunction setsHaveIntersection<T>(setA: Set<T>, setB: Set<T>): boolean {\n  const [smallerSet, largerSet] = setA.size <= setB.size ? [setA, setB] : [setB, setA];\n\n  for (let item of smallerSet) {\n    if (largerSet.has(item)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n","import { useCallback, useReducer } from \"react\";\nimport { randomId } from \"@copilotkit/shared\";\n\nexport type FlatCategoryStoreId = string;\n\nexport interface UseFlatCategoryStoreReturn<T> {\n  addElement: (value: T, categories: string[]) => FlatCategoryStoreId;\n  removeElement: (id: FlatCategoryStoreId) => void;\n  allElements: (categories: string[]) => T[];\n}\n\ninterface FlatCategoryStoreElement<T> {\n  id: FlatCategoryStoreId;\n  value: T;\n  categories: Set<string>;\n}\n\nconst useFlatCategoryStore = <T>(): UseFlatCategoryStoreReturn<T> => {\n  const [elements, dispatch] = useReducer<\n    React.Reducer<Map<FlatCategoryStoreId, FlatCategoryStoreElement<T>>, Action<T>>\n  >(flatCategoryStoreReducer, new Map<FlatCategoryStoreId, FlatCategoryStoreElement<T>>());\n\n  const addElement = useCallback((value: T, categories: string[]): FlatCategoryStoreId => {\n    const newId = randomId();\n    dispatch({\n      type: \"ADD_ELEMENT\",\n      value,\n      id: newId,\n      categories,\n    });\n    return newId;\n  }, []);\n\n  const removeElement = useCallback((id: FlatCategoryStoreId): void => {\n    dispatch({ type: \"REMOVE_ELEMENT\", id });\n  }, []);\n\n  const allElements = useCallback(\n    (categories: string[]): T[] => {\n      const categoriesSet = new Set(categories);\n      const result: T[] = [];\n      elements.forEach((element) => {\n        if (setsHaveIntersection(categoriesSet, element.categories)) {\n          result.push(element.value);\n        }\n      });\n      return result;\n    },\n    [elements],\n  );\n\n  return { addElement, removeElement, allElements };\n};\n\nexport default useFlatCategoryStore;\n\n// Action types\ntype Action<T> =\n  | {\n      type: \"ADD_ELEMENT\";\n      value: T;\n      id: FlatCategoryStoreId;\n      categories: string[];\n    }\n  | { type: \"REMOVE_ELEMENT\"; id: FlatCategoryStoreId };\n\n// Reducer\nfunction flatCategoryStoreReducer<T>(\n  state: Map<FlatCategoryStoreId, FlatCategoryStoreElement<T>>,\n  action: Action<T>,\n): Map<FlatCategoryStoreId, FlatCategoryStoreElement<T>> {\n  switch (action.type) {\n    case \"ADD_ELEMENT\": {\n      const { value, id, categories } = action;\n      const newElement: FlatCategoryStoreElement<T> = {\n        id,\n        value,\n        categories: new Set(categories),\n      };\n      const newState = new Map(state);\n      newState.set(id, newElement);\n      return newState;\n    }\n    case \"REMOVE_ELEMENT\": {\n      const newState = new Map(state);\n      newState.delete(action.id);\n      return newState;\n    }\n    default:\n      return state;\n  }\n}\n\nfunction setsHaveIntersection<T>(setA: Set<T>, setB: Set<T>): boolean {\n  const [smallerSet, largerSet] = setA.size <= setB.size ? [setA, setB] : [setB, setA];\n\n  for (let item of smallerSet) {\n    if (largerSet.has(item)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n","/**\n * An internal context to separate the messages state (which is constantly changing) from the rest of CopilotKit context\n */\n\nimport { useState } from \"react\";\nimport { CopilotMessagesContext } from \"../../context/copilot-messages-context\";\nimport { Message } from \"@copilotkit/runtime-client-gql\";\nimport { CopilotKitProps } from \"./copilotkit-props\";\n\nexport function CopilotMessages({ children, ...props }: CopilotKitProps) {\n  const [messages, setMessages] = useState<Message[]>([]);\n\n  return (\n    <CopilotMessagesContext.Provider\n      value={{\n        messages,\n        setMessages,\n      }}\n    >\n      {children}\n    </CopilotMessagesContext.Provider>\n  );\n}\n","/**\n * An internal context to separate the messages state (which is constantly changing) from the rest of CopilotKit context\n */\n\nimport { Message } from \"@copilotkit/runtime-client-gql\";\nimport React from \"react\";\n\nexport interface CopilotMessagesContextParams {\n  messages: Message[];\n  setMessages: React.Dispatch<React.SetStateAction<Message[]>>;\n}\n\nconst emptyCopilotContext: CopilotMessagesContextParams = {\n  messages: [],\n  setMessages: () => [],\n};\n\nexport const CopilotMessagesContext =\n  React.createContext<CopilotMessagesContextParams>(emptyCopilotContext);\n\nexport function useCopilotMessagesContext(): CopilotMessagesContextParams {\n  const context = React.useContext(CopilotMessagesContext);\n  if (context === emptyCopilotContext) {\n    throw new Error(\n      \"A messages consuming component was not wrapped with `<CopilotMessages> {...} </CopilotMessages>`\",\n    );\n  }\n  return context;\n}\n","/**\n * `useCopilotChat` is a React hook that lets you directly interact with the\n * Copilot instance. Use to implement a fully custom UI (headless UI) or to\n * programmatically interact with the Copilot instance managed by the default\n * UI.\n *\n * ## Usage\n *\n * ### Simple Usage\n *\n * ```tsx\n * import { useCopilotChat } from \"@copilotkit/react-core\";\n * import { Role, TextMessage } from \"@copilotkit/runtime-client-gql\";\n *\n * export function YourComponent() {\n *   const { appendMessage } = useCopilotChat();\n *\n *   appendMessage(\n *     new TextMessage({\n *       content: \"Hello World\",\n *       role: Role.User,\n *     }),\n *   );\n * }\n * ```\n *\n * `useCopilotChat` returns an object with the following properties:\n *\n * ```tsx\n * const {\n *   visibleMessages, // An array of messages that are currently visible in the chat.\n *   appendMessage, // A function to append a message to the chat.\n *   setMessages, // A function to set the messages in the chat.\n *   deleteMessage, // A function to delete a message from the chat.\n *   reloadMessages, // A function to reload the messages from the API.\n *   stopGeneration, // A function to stop the generation of the next message.\n *   isLoading, // A boolean indicating if the chat is loading.\n * } = useCopilotChat();\n * ```\n */\nimport { useRef, useEffect, useCallback } from \"react\";\nimport { useCopilotContext } from \"../context/copilot-context\";\nimport { Message, Role, TextMessage } from \"@copilotkit/runtime-client-gql\";\nimport { SystemMessageFunction } from \"../types\";\nimport { useChat } from \"./use-chat\";\nimport { defaultCopilotContextCategories } from \"../components\";\nimport { MessageStatusCode } from \"@copilotkit/runtime-client-gql\";\nimport { CoAgentStateRenderHandlerArguments } from \"@copilotkit/shared\";\nimport { useCopilotMessagesContext } from \"../context\";\n\nexport interface UseCopilotChatOptions {\n  /**\n   * A unique identifier for the chat. If not provided, a random one will be\n   * generated. When provided, the `useChat` hook with the same `id` will\n   * have shared states across components.\n   */\n  id?: string;\n\n  /**\n   * HTTP headers to be sent with the API request.\n   */\n  headers?: Record<string, string> | Headers;\n  /**\n   * System messages of the chat. Defaults to an empty array.\n   */\n  initialMessages?: Message[];\n\n  /**\n   * A function to generate the system message. Defaults to `defaultSystemMessage`.\n   */\n  makeSystemMessage?: SystemMessageFunction;\n}\n\nexport interface UseCopilotChatReturn {\n  visibleMessages: Message[];\n  appendMessage: (message: Message) => Promise<void>;\n  setMessages: (messages: Message[]) => void;\n  deleteMessage: (messageId: string) => void;\n  reloadMessages: () => Promise<void>;\n  stopGeneration: () => void;\n  isLoading: boolean;\n}\n\nexport function useCopilotChat({\n  makeSystemMessage,\n  ...options\n}: UseCopilotChatOptions = {}): UseCopilotChatReturn {\n  const {\n    getContextString,\n    getFunctionCallHandler,\n    copilotApiConfig,\n    isLoading,\n    setIsLoading,\n    chatInstructions,\n    actions,\n\n    coagentStates,\n    setCoagentStates,\n    coAgentStateRenders,\n    agentSession,\n    setAgentSession,\n  } = useCopilotContext();\n  const { messages, setMessages } = useCopilotMessagesContext();\n\n  // We need to ensure that makeSystemMessageCallback always uses the latest\n  // useCopilotReadable data.\n  const latestGetContextString = useUpdatedRef(getContextString);\n  const deleteMessage = useCallback(\n    (messageId: string) => {\n      setMessages((prev) => prev.filter((message) => message.id !== messageId));\n    },\n    [setMessages],\n  );\n\n  const makeSystemMessageCallback = useCallback(() => {\n    const systemMessageMaker = makeSystemMessage || defaultSystemMessage;\n    // this always gets the latest context string\n    const contextString = latestGetContextString.current([], defaultCopilotContextCategories); // TODO: make the context categories configurable\n\n    return new TextMessage({\n      content: systemMessageMaker(contextString, chatInstructions),\n      role: Role.System,\n    });\n  }, [getContextString, makeSystemMessage, chatInstructions]);\n\n  const onCoAgentStateRender = useCallback(\n    async (args: CoAgentStateRenderHandlerArguments) => {\n      const { name, nodeName, state } = args;\n      let action = Object.values(coAgentStateRenders).find(\n        (action) => action.name === name && action.nodeName === nodeName,\n      );\n      if (!action) {\n        action = Object.values(coAgentStateRenders).find(\n          (action) => action.name === name && !action.nodeName,\n        );\n      }\n      if (action) {\n        await action.handler?.({ state, nodeName });\n      }\n    },\n    [coAgentStateRenders],\n  );\n\n  const { append, reload, stop } = useChat({\n    ...options,\n    actions: Object.values(actions),\n    copilotConfig: copilotApiConfig,\n    initialMessages: options.initialMessages || [],\n    onFunctionCall: getFunctionCallHandler(),\n    onCoAgentStateRender,\n    messages,\n    setMessages,\n    makeSystemMessageCallback,\n    isLoading,\n    setIsLoading,\n    coagentStates,\n    setCoagentStates,\n    agentSession,\n    setAgentSession,\n  });\n\n  // this is a workaround born out of a bug that Athena insessently ran into.\n  // We could not find the origin of the bug, however, it was clear that an outdated version of the append function was being used somehow --\n  // it referecned the old state of the messages array, and not the latest one.\n  //\n  // We want to make copilotkit as abuse-proof as possible, so we are adding this workaround to ensure that the latest version of the append function is always used.\n  //\n  // How does this work?\n  // we store the relevant function in a ref that is always up-to-date, and then we use that ref in the callback.\n  const latestAppend = useUpdatedRef(append);\n  const latestAppendFunc = useCallback(\n    (message: Message) => {\n      return latestAppend.current(message);\n    },\n    [latestAppend],\n  );\n\n  const latestReload = useUpdatedRef(reload);\n  const latestReloadFunc = useCallback(() => {\n    return latestReload.current();\n  }, [latestReload]);\n\n  const latestStop = useUpdatedRef(stop);\n  const latestStopFunc = useCallback(() => {\n    return latestStop.current();\n  }, [latestStop]);\n\n  const latestDelete = useUpdatedRef(deleteMessage);\n  const latestDeleteFunc = useCallback(\n    (messageId: string) => {\n      return latestDelete.current(messageId);\n    },\n    [latestDelete],\n  );\n\n  const latestSetMessages = useUpdatedRef(setMessages);\n  const latestSetMessagesFunc = useCallback(\n    (messages: Message[]) => {\n      return latestSetMessages.current(messages);\n    },\n    [latestSetMessages],\n  );\n\n  return {\n    visibleMessages: messages,\n    appendMessage: latestAppendFunc,\n    setMessages: latestSetMessagesFunc,\n    reloadMessages: latestReloadFunc,\n    stopGeneration: latestStopFunc,\n    deleteMessage: latestDeleteFunc,\n    isLoading,\n  };\n}\n\n// store `value` in a ref and update\n// it whenever it changes.\nfunction useUpdatedRef<T>(value: T) {\n  const ref = useRef(value);\n\n  useEffect(() => {\n    ref.current = value;\n  }, [value]);\n\n  return ref;\n}\n\nexport function defaultSystemMessage(\n  contextString: string,\n  additionalInstructions?: string,\n): string {\n  return (\n    `\nPlease act as an efficient, competent, conscientious, and industrious professional assistant.\n\nHelp the user achieve their goals, and you do so in a way that is as efficient as possible, without unnecessary fluff, but also without sacrificing professionalism.\nAlways be polite and respectful, and prefer brevity over verbosity.\n\nThe user has provided you with the following context:\n\\`\\`\\`\n${contextString}\n\\`\\`\\`\n\nThey have also provided you with functions you can call to initiate actions on their behalf, or functions you can call to receive more information.\n\nPlease assist them as best you can.\n\nYou can ask them for clarifying questions if needed, but don't be annoying about it. If you can reasonably 'fill in the blanks' yourself, do so.\n\nIf you would like to call a function, call it without saying anything else.\n` + (additionalInstructions ? `\\n\\n${additionalInstructions}` : \"\")\n  );\n}\n","import { useRef } from \"react\";\nimport {\n  FunctionCallHandler,\n  COPILOT_CLOUD_PUBLIC_API_KEY_HEADER,\n  actionParametersToJsonSchema,\n  CoAgentStateRenderHandler,\n} from \"@copilotkit/shared\";\nimport {\n  Message,\n  TextMessage,\n  ActionExecutionMessage,\n  ResultMessage,\n  CopilotRuntimeClient,\n  convertMessagesToGqlInput,\n  filterAdjacentAgentStateMessages,\n  filterAgentStateMessages,\n  convertGqlOutputToMessages,\n  MessageStatusCode,\n  MessageRole,\n  Role,\n  CopilotRequestType,\n  AgentStateMessage,\n} from \"@copilotkit/runtime-client-gql\";\n\nimport { CopilotApiConfig } from \"../context\";\nimport { FrontendAction } from \"../types/frontend-action\";\nimport { CoagentState } from \"../types/coagent-state\";\nimport { AgentSession } from \"../context/copilot-context\";\n\nexport type UseChatOptions = {\n  /**\n   * System messages of the chat. Defaults to an empty array.\n   */\n  initialMessages?: Message[];\n  /**\n   * Callback function to be called when a function call is received.\n   * If the function returns a `ChatRequest` object, the request will be sent\n   * automatically to the API and will be used to update the chat.\n   */\n  onFunctionCall?: FunctionCallHandler;\n\n  /**\n   * Callback function to be called when a coagent action is received.\n   */\n  onCoAgentStateRender?: CoAgentStateRenderHandler;\n\n  /**\n   * Function definitions to be sent to the API.\n   */\n  actions: FrontendAction<any>[];\n\n  /**\n   * The CopilotKit API configuration.\n   */\n  copilotConfig: CopilotApiConfig;\n\n  /**\n   * The current list of messages in the chat.\n   */\n  messages: Message[];\n  /**\n   * The setState-powered method to update the chat messages.\n   */\n  setMessages: React.Dispatch<React.SetStateAction<Message[]>>;\n\n  /**\n   * A callback to get the latest system message.\n   */\n  makeSystemMessageCallback: () => TextMessage;\n\n  /**\n   * Whether the API request is in progress\n   */\n  isLoading: boolean;\n\n  /**\n   * setState-powered method to update the isChatLoading value\n   */\n  setIsLoading: React.Dispatch<React.SetStateAction<boolean>>;\n\n  /**\n   * The current list of coagent states.\n   */\n  coagentStates: Record<string, CoagentState>;\n\n  /**\n   * setState-powered method to update the agent states\n   */\n  setCoagentStates: React.Dispatch<React.SetStateAction<Record<string, CoagentState>>>;\n\n  /**\n   * The current agent session.\n   */\n  agentSession: AgentSession | null;\n\n  /**\n   * setState-powered method to update the agent session\n   */\n  setAgentSession: React.Dispatch<React.SetStateAction<AgentSession | null>>;\n};\n\nexport type UseChatHelpers = {\n  /**\n   * Append a user message to the chat list. This triggers the API call to fetch\n   * the assistant's response.\n   * @param message The message to append\n   */\n  append: (message: Message) => Promise<void>;\n  /**\n   * Reload the last AI chat response for the given chat history. If the last\n   * message isn't from the assistant, it will request the API to generate a\n   * new response.\n   */\n  reload: () => Promise<void>;\n  /**\n   * Abort the current request immediately, keep the generated tokens if any.\n   */\n  stop: () => void;\n};\n\nexport function useChat(options: UseChatOptions): UseChatHelpers {\n  const {\n    messages,\n    setMessages,\n    makeSystemMessageCallback,\n    copilotConfig,\n    setIsLoading,\n    initialMessages,\n    isLoading,\n    actions,\n    onFunctionCall,\n    onCoAgentStateRender,\n    setCoagentStates,\n    coagentStates,\n    agentSession,\n    setAgentSession,\n  } = options;\n\n  const abortControllerRef = useRef<AbortController>();\n  const threadIdRef = useRef<string | null>(null);\n  const runIdRef = useRef<string | null>(null);\n\n  const runChatCompletionRef = useRef<(previousMessages: Message[]) => Promise<Message[]>>();\n  // We need to keep a ref of coagent states because of renderAndWait - making sure\n  // the latest state is sent to the API\n  // This is a workaround and needs to be addressed in the future\n  const coagentStatesRef = useRef<Record<string, CoagentState>>(coagentStates);\n  coagentStatesRef.current = coagentStates;\n  const agentSessionRef = useRef<AgentSession | null>(agentSession);\n  agentSessionRef.current = agentSession;\n\n  const publicApiKey = copilotConfig.publicApiKey;\n\n  const headers = {\n    ...(copilotConfig.headers || {}),\n    ...(publicApiKey ? { [COPILOT_CLOUD_PUBLIC_API_KEY_HEADER]: publicApiKey } : {}),\n  };\n\n  const runtimeClient = new CopilotRuntimeClient({\n    url: copilotConfig.chatApiEndpoint,\n    publicApiKey: copilotConfig.publicApiKey,\n    headers,\n    credentials: copilotConfig.credentials,\n  });\n\n  const runChatCompletion = async (previousMessages: Message[]): Promise<Message[]> => {\n    setIsLoading(true);\n\n    // this message is just a placeholder. It will disappear once the first real message\n    // is received\n    let newMessages: Message[] = [\n      new TextMessage({\n        content: \"\",\n        role: Role.Assistant,\n      }),\n    ];\n    const abortController = new AbortController();\n    abortControllerRef.current = abortController;\n\n    setMessages([...previousMessages, ...newMessages]);\n\n    const systemMessage = makeSystemMessageCallback();\n\n    const messagesWithContext = [systemMessage, ...(initialMessages || []), ...previousMessages];\n\n    const stream = CopilotRuntimeClient.asStream(\n      runtimeClient.generateCopilotResponse({\n        data: {\n          frontend: {\n            actions: actions\n              .filter((action) => !action.disabled)\n              .map((action) => ({\n                name: action.name,\n                description: action.description || \"\",\n                jsonSchema: JSON.stringify(actionParametersToJsonSchema(action.parameters || [])),\n              })),\n            url: window.location.href,\n          },\n          threadId: threadIdRef.current,\n          runId: runIdRef.current,\n          messages: convertMessagesToGqlInput(filterAgentStateMessages(messagesWithContext)),\n          ...(copilotConfig.cloud\n            ? {\n                cloud: {\n                  ...(copilotConfig.cloud.guardrails?.input?.restrictToTopic?.enabled\n                    ? {\n                        guardrails: {\n                          inputValidationRules: {\n                            allowList:\n                              copilotConfig.cloud.guardrails.input.restrictToTopic.validTopics,\n                            denyList:\n                              copilotConfig.cloud.guardrails.input.restrictToTopic.invalidTopics,\n                          },\n                        },\n                      }\n                    : {}),\n                },\n              }\n            : {}),\n          metadata: {\n            requestType: CopilotRequestType.Chat,\n          },\n          ...(agentSessionRef.current\n            ? {\n                agentSession: agentSessionRef.current,\n              }\n            : {}),\n          agentStates: Object.values(coagentStatesRef.current).map((state) => ({\n            agentName: state.name,\n            state: JSON.stringify(state.state),\n          })),\n        },\n        properties: copilotConfig.properties,\n        signal: abortControllerRef.current?.signal,\n      }),\n    );\n\n    const guardrailsEnabled =\n      copilotConfig.cloud?.guardrails?.input?.restrictToTopic.enabled || false;\n\n    const reader = stream.getReader();\n\n    let actionResults: { [id: string]: string } = {};\n    let executedCoAgentStateRenders: string[] = [];\n    let followUp: FrontendAction[\"followUp\"] = undefined;\n\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n\n        if (done) {\n          break;\n        }\n\n        if (!value?.generateCopilotResponse) {\n          continue;\n        }\n\n        threadIdRef.current = value.generateCopilotResponse.threadId || null;\n        runIdRef.current = value.generateCopilotResponse.runId || null;\n\n        const messages = convertGqlOutputToMessages(\n          filterAdjacentAgentStateMessages(value.generateCopilotResponse.messages),\n        );\n\n        if (messages.length === 0) {\n          continue;\n        }\n\n        newMessages = [];\n\n        // request failed, display error message\n        if (\n          value.generateCopilotResponse.status?.__typename === \"FailedResponseStatus\" &&\n          value.generateCopilotResponse.status.reason === \"GUARDRAILS_VALIDATION_FAILED\"\n        ) {\n          newMessages = [\n            new TextMessage({\n              role: MessageRole.Assistant,\n              content: value.generateCopilotResponse.status.details?.guardrailsReason || \"\",\n            }),\n          ];\n        }\n\n        // add messages to the chat\n        else {\n          for (const message of messages) {\n            newMessages.push(message);\n            // execute regular action executions\n            if (\n              message.isActionExecutionMessage() &&\n              message.status.code !== MessageStatusCode.Pending &&\n              message.scope === \"client\" &&\n              onFunctionCall\n            ) {\n              if (!(message.id in actionResults)) {\n                // Do not execute a function call if guardrails are enabled but the status is not known\n                if (guardrailsEnabled && value.generateCopilotResponse.status === undefined) {\n                  break;\n                }\n                // execute action\n                try {\n                  // We update the message state before calling the handler so that the render\n                  // function can be called with `executing` state\n                  setMessages([...previousMessages, ...newMessages]);\n\n                  const action = actions.find((action) => action.name === message.name);\n\n                  if (action) {\n                    followUp = action.followUp;\n                  }\n\n                  const result = await onFunctionCall({\n                    messages: previousMessages,\n                    name: message.name,\n                    args: message.arguments,\n                  });\n                  actionResults[message.id] = result;\n                } catch (e) {\n                  actionResults[message.id] = `Failed to execute action ${message.name}`;\n                  console.error(`Failed to execute action ${message.name}: ${e}`);\n                }\n              }\n              // add the result message\n              newMessages.push(\n                new ResultMessage({\n                  result: ResultMessage.encodeResult(actionResults[message.id]),\n                  actionExecutionId: message.id,\n                  actionName: message.name,\n                }),\n              );\n            }\n            // execute coagent actions\n            if (\n              message.isAgentStateMessage() &&\n              !message.active &&\n              !executedCoAgentStateRenders.includes(message.id) &&\n              onCoAgentStateRender\n            ) {\n              // Do not execute a coagent action if guardrails are enabled but the status is not known\n              if (guardrailsEnabled && value.generateCopilotResponse.status === undefined) {\n                break;\n              }\n              // execute coagent action\n              await onCoAgentStateRender({\n                name: message.agentName,\n                nodeName: message.nodeName,\n                state: message.state,\n              });\n              executedCoAgentStateRenders.push(message.id);\n            }\n          }\n\n          const lastAgentStateMessage = [...messages]\n            .reverse()\n            .find((message) => message.isAgentStateMessage());\n\n          if (lastAgentStateMessage) {\n            setCoagentStates((prevAgentStates) => ({\n              ...prevAgentStates,\n              [lastAgentStateMessage.agentName]: {\n                name: lastAgentStateMessage.agentName,\n                state: lastAgentStateMessage.state,\n                running: lastAgentStateMessage.running,\n                active: lastAgentStateMessage.active,\n                threadId: lastAgentStateMessage.threadId,\n                nodeName: lastAgentStateMessage.nodeName,\n                runId: lastAgentStateMessage.runId,\n              },\n            }));\n            if (lastAgentStateMessage.running) {\n              setAgentSession({\n                threadId: lastAgentStateMessage.threadId,\n                agentName: lastAgentStateMessage.agentName,\n                nodeName: lastAgentStateMessage.nodeName,\n              });\n            } else {\n              setAgentSession(null);\n            }\n          }\n        }\n\n        if (newMessages.length > 0) {\n          // Update message state\n          setMessages([...previousMessages, ...newMessages]);\n        }\n      }\n\n      if (\n        // if followUp is not explicitly false\n        followUp !== false &&\n        // if we have client side results\n        (Object.values(actionResults).length ||\n          // or the last message we received is a result\n          (newMessages.length && newMessages[newMessages.length - 1].isResultMessage()))\n      ) {\n        // run the completion again and return the result\n\n        // wait for next tick to make sure all the react state updates\n        // - tried using react-dom's flushSync, but it did not work\n        await new Promise((resolve) => setTimeout(resolve, 10));\n\n        return await runChatCompletionRef.current!([...previousMessages, ...newMessages]);\n      } else {\n        return newMessages.slice();\n      }\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  runChatCompletionRef.current = runChatCompletion;\n\n  const runChatCompletionAndHandleFunctionCall = async (messages: Message[]): Promise<void> => {\n    await runChatCompletionRef.current!(messages);\n  };\n\n  const append = async (message: Message): Promise<void> => {\n    if (isLoading) {\n      return;\n    }\n\n    const newMessages = [...messages, message];\n    setMessages(newMessages);\n    return runChatCompletionAndHandleFunctionCall(newMessages);\n  };\n\n  const reload = async (): Promise<void> => {\n    if (isLoading || messages.length === 0) {\n      return;\n    }\n    let newMessages = [...messages];\n    const lastMessage = messages[messages.length - 1];\n\n    if (lastMessage.isTextMessage() && lastMessage.role === \"assistant\") {\n      newMessages = newMessages.slice(0, -1);\n    }\n\n    setMessages(newMessages);\n\n    return runChatCompletionAndHandleFunctionCall(newMessages);\n  };\n\n  const stop = (): void => {\n    abortControllerRef.current?.abort();\n  };\n\n  return {\n    append,\n    reload,\n    stop,\n  };\n}\n","/**\n * <img src=\"/images/use-copilot-action/useCopilotAction.gif\" width=\"500\" />\n * `useCopilotAction` is a React hook that you can use in your application to provide\n * custom actions that can be called by the AI. Essentially, it allows the Copilot to\n * execute these actions contextually during a chat, based on the user's interactions\n * and needs.\n *\n * Here's how it works:\n *\n * Use `useCopilotAction` to set up actions that the Copilot can call. To provide\n * more context to the Copilot, you can provide it with a `description` (for example to explain\n * what the action does, under which conditions it can be called, etc.).\n *\n * Then you define the parameters of the action, which can be simple, e.g. primitives like strings or numbers,\n * or complex, e.g. objects or arrays.\n *\n * Finally, you provide a `handler` function that receives the parameters and returns a result.\n * CopilotKit takes care of automatically inferring the parameter types, so you get type safety\n * and autocompletion for free.\n *\n * To render a custom UI for the action, you can provide a `render()` function. This function\n * lets you render a custom component or return a string to display.\n *\n * ## Usage\n *\n * ### Simple Usage\n *\n * ```tsx\n * useCopilotAction({\n *   name: \"sayHello\",\n *   description: \"Say hello to someone.\",\n *   parameters: [\n *     {\n *       name: \"name\",\n *       type: \"string\",\n *       description: \"name of the person to say greet\",\n *     },\n *   ],\n *   handler: async ({ name }) => {\n *     alert(`Hello, ${name}!`);\n *   },\n * });\n * ```\n *\n * ## Generative UI\n *\n * This hooks enables you to dynamically generate UI elements and render them in the copilot chat. For more information, check out the [Generative UI](/concepts/generative-ui) page.\n */\nimport { useRef, useEffect } from \"react\";\nimport { FrontendAction, ActionRenderProps, ActionRenderPropsWait } from \"../types/frontend-action\";\nimport { useCopilotContext } from \"../context/copilot-context\";\nimport { Parameter, randomId } from \"@copilotkit/shared\";\n\n// We implement useCopilotAction dependency handling so that\n// the developer has the option to not provide any dependencies.\n// In this case, we assume they want to update the handler on each rerender.\n// To avoid getting stuck in an infinite loop, we update the handler directly,\n// skipping React state updates.\n// This is ok in this case, because the handler is not part of any UI that\n// needs to be updated.\n// useCallback, useMemo or other memoization techniques are not suitable here,\n// because they will cause a infinite rerender loop.\nexport function useCopilotAction<const T extends Parameter[] | [] = []>(\n  action: FrontendAction<T>,\n  dependencies?: any[],\n): void {\n  const { setAction, removeAction, actions, chatComponentsCache } = useCopilotContext();\n  const idRef = useRef<string>(randomId());\n  const renderAndWaitRef = useRef<RenderAndWait | null>(null);\n\n  // clone the action to avoid mutating the original object\n  action = { ...action };\n\n  // If the developer provides a renderAndWait function, we transform the action\n  // to use a promise internally, so that we can treat it like a normal action.\n  if (action.renderAndWait) {\n    const renderAndWait = action.renderAndWait!;\n\n    // remove the renderAndWait function from the action\n    action.renderAndWait = undefined;\n\n    // add a handler that will be called when the action is executed\n    action.handler = (async () => {\n      // we create a new promise when the handler is called\n      let resolve: (result: any) => void;\n      let reject: (error: any) => void;\n      const promise = new Promise<any>((resolvePromise, rejectPromise) => {\n        resolve = resolvePromise;\n        reject = rejectPromise;\n      });\n      renderAndWaitRef.current = { promise, resolve: resolve!, reject: reject! };\n      // then we await the promise (it will be resolved in the original renderAndWait function)\n      return await promise;\n    }) as any;\n\n    // add a render function that will be called when the action is rendered\n    action.render = ((props: ActionRenderProps<any>): React.ReactElement => {\n      const waitProps: ActionRenderPropsWait<any> = {\n        status: props.status as any,\n        args: props.args,\n        result: props.result,\n        handler: props.status === \"executing\" ? renderAndWaitRef.current!.resolve : undefined,\n      };\n      return renderAndWait(waitProps);\n    }) as any;\n  }\n\n  // If the developer doesn't provide dependencies, we assume they want to\n  // update handler and render function when the action object changes.\n  // This ensures that any captured variables in the handler are up to date.\n  if (dependencies === undefined) {\n    if (actions[idRef.current]) {\n      actions[idRef.current].handler = action.handler as any;\n      if (typeof action.render === \"function\") {\n        if (chatComponentsCache.current !== null) {\n          chatComponentsCache.current.actions[action.name] = action.render;\n        }\n      }\n    }\n  }\n\n  useEffect(() => {\n    setAction(idRef.current, action as any);\n    if (chatComponentsCache.current !== null && action.render !== undefined) {\n      chatComponentsCache.current.actions[action.name] = action.render;\n    }\n    return () => {\n      // NOTE: For now, we don't remove the chatComponentsCache entry when the action is removed.\n      // This is because we currently don't have access to the messages array in CopilotContext.\n      removeAction(idRef.current);\n    };\n  }, [\n    setAction,\n    removeAction,\n    action.description,\n    action.name,\n    action.disabled,\n    // This should be faster than deep equality checking\n    // In addition, all major JS engines guarantee the order of object keys\n    JSON.stringify(action.parameters),\n    // include render only if it's a string\n    typeof action.render === \"string\" ? action.render : undefined,\n    // dependencies set by the developer\n    ...(dependencies || []),\n  ]);\n}\n\ninterface RenderAndWait {\n  promise: Promise<any>;\n  resolve: (result: any) => void;\n  reject: (error: any) => void;\n}\n\n// Usage Example:\n// useCopilotAction({\n//   name: \"myAction\",\n//   parameters: [\n//     { name: \"arg1\", type: \"string\", enum: [\"option1\", \"option2\", \"option3\"], required: false },\n//     { name: \"arg2\", type: \"number\" },\n//     {\n//       name: \"arg3\",\n//       type: \"object\",\n//       attributes: [\n//         { name: \"nestedArg1\", type: \"boolean\" },\n//         { name: \"xyz\", required: false },\n//       ],\n//     },\n//     { name: \"arg4\", type: \"number[]\" },\n//   ],\n//   handler: ({ arg1, arg2, arg3, arg4 }) => {\n//     const x = arg3.nestedArg1;\n//     const z = arg3.xyz;\n//     console.log(arg1, arg2, arg3);\n//   },\n// });\n\n// useCopilotAction({\n//   name: \"myAction\",\n//   handler: () => {\n//     console.log(\"No parameters provided.\");\n//   },\n// });\n","import { useRef, useContext, useEffect } from \"react\";\nimport { CopilotContext } from \"../context/copilot-context\";\nimport { randomId } from \"@copilotkit/shared\";\nimport { CoAgentStateRender } from \"../types/coagent-action\";\n\n// We implement useCoAgentStateRender dependency handling so that\n// the developer has the option to not provide any dependencies.\n// see useCopilotAction for more details about this approach.\nexport function useCoAgentStateRender<T = any>(\n  action: CoAgentStateRender<T>,\n  dependencies?: any[],\n): void {\n  const {\n    setCoAgentStateRender,\n    removeCoAgentStateRender,\n    coAgentStateRenders,\n    chatComponentsCache,\n  } = useContext(CopilotContext);\n  const idRef = useRef<string>(randomId());\n\n  const key = `${action.name}-${action.nodeName || \"global\"}`;\n\n  if (dependencies === undefined) {\n    if (coAgentStateRenders[idRef.current]) {\n      coAgentStateRenders[idRef.current].handler = action.handler as any;\n      if (typeof action.render === \"function\") {\n        if (chatComponentsCache.current !== null) {\n          chatComponentsCache.current.coAgentStateRenders[key] = action.render;\n        }\n      }\n    }\n  }\n\n  useEffect(() => {\n    setCoAgentStateRender(idRef.current, action as any);\n    if (chatComponentsCache.current !== null && action.render !== undefined) {\n      chatComponentsCache.current.coAgentStateRenders[key] = action.render;\n    }\n    return () => {\n      removeCoAgentStateRender(idRef.current);\n    };\n  }, [\n    setCoAgentStateRender,\n    removeCoAgentStateRender,\n    action.name,\n    // include render only if it's a string\n    typeof action.render === \"string\" ? action.render : undefined,\n    // dependencies set by the developer\n    ...(dependencies || []),\n  ]);\n}\n","import { useEffect, useRef } from \"react\";\nimport { useCopilotContext } from \"../context/copilot-context\";\nimport { DocumentPointer } from \"../types\";\n\n/**\n * Makes a document readable by Copilot.\n * @param document The document to make readable.\n * @param categories The categories to associate with the document.\n * @param dependencies The dependencies to use for the effect.\n * @returns The id of the document.\n */\nexport function useMakeCopilotDocumentReadable(\n  document: DocumentPointer,\n  categories?: string[],\n  dependencies: any[] = [],\n): string | undefined {\n  const { addDocumentContext, removeDocumentContext } = useCopilotContext();\n  const idRef = useRef<string>();\n\n  useEffect(() => {\n    const id = addDocumentContext(document, categories);\n    idRef.current = id;\n\n    return () => {\n      removeDocumentContext(id);\n    };\n  }, [addDocumentContext, removeDocumentContext, ...dependencies]);\n\n  return idRef.current;\n}\n","/**\n * `useCopilotReadable` is a React hook that provides app-state and other information\n * to the Copilot. Optionally, the hook can also handle hierarchical state within your\n * application, passing these parent-child relationships to the Copilot.\n *\n * ## Usage\n *\n * ### Simple Usage\n *\n * In its most basic usage, useCopilotReadable accepts a single string argument\n * representing any piece of app state, making it available for the Copilot to use\n * as context when responding to user input.\n *\n * ```tsx\n * import { useCopilotReadable } from \"@copilotkit/react-core\";\n *\n * export function MyComponent() {\n *   const [employees, setEmployees] = useState([]);\n *\n *   useCopilotReadable({\n *     description: \"The list of employees\",\n *     value: employees,\n *   });\n * }\n * ```\n *\n * ### Nested Components\n *\n * Optionally, you can maintain the hierarchical structure of information by passing\n * `parentId`. This allows you to use `useCopilotReadable` in nested components:\n *\n * ```tsx /employeeContextId/1 {17,23}\n * import { useCopilotReadable } from \"@copilotkit/react-core\";\n *\n * function Employee(props: EmployeeProps) {\n *   const { employeeName, workProfile, metadata } = props;\n *\n *   // propagate any information to copilot\n *   const employeeContextId = useCopilotReadable({\n *     description: \"Employee name\",\n *     value: employeeName\n *   });\n *\n *   // Pass a parentID to maintain a hierarchical structure.\n *   // Especially useful with child React components, list elements, etc.\n *   useCopilotReadable({\n *     description: \"Work profile\",\n *     value: workProfile.description(),\n *     parentId: employeeContextId\n *   });\n *\n *   useCopilotReadable({\n *     description: \"Employee metadata\",\n *     value: metadata.description(),\n *     parentId: employeeContextId\n *   });\n *\n *   return (\n *     // Render as usual...\n *   );\n * }\n * ```\n */\nimport { useEffect, useRef } from \"react\";\nimport { useCopilotContext } from \"../context/copilot-context\";\n\n/**\n * Options for the useCopilotReadable hook.\n */\nexport interface UseCopilotReadableOptions {\n  /**\n   * The description of the information to be added to the Copilot context.\n   */\n  description: string;\n  /**\n   * The value to be added to the Copilot context. Object values are automatically stringified.\n   */\n  value: any;\n  /**\n   * The ID of the parent context, if any.\n   */\n  parentId?: string;\n  /**\n   * An array of categories to control which context are visible where. Particularly useful\n   * with CopilotTextarea (see `useMakeAutosuggestionFunction`)\n   */\n  categories?: string[];\n\n  /**\n   * A custom conversion function to use to serialize the value to a string. If not provided, the value\n   * will be serialized using `JSON.stringify`.\n   */\n  convert?: (description: string, value: any) => string;\n}\n\nfunction convertToJSON(description: string, value: any): string {\n  return `${description}: ${typeof value === \"string\" ? value : JSON.stringify(value)}`;\n}\n\n/**\n * Adds the given information to the Copilot context to make it readable by Copilot.\n */\nexport function useCopilotReadable(\n  { description, value, parentId, categories, convert }: UseCopilotReadableOptions,\n  dependencies?: any[],\n): string | undefined {\n  const { addContext, removeContext } = useCopilotContext();\n  const idRef = useRef<string>();\n  convert = convert || convertToJSON;\n\n  const information = convert(description, value);\n\n  useEffect(() => {\n    const id = addContext(information, parentId, categories);\n    idRef.current = id;\n\n    return () => {\n      removeContext(id);\n    };\n  }, [information, parentId, addContext, removeContext, ...(dependencies || [])]);\n\n  return idRef.current;\n}\n","import { useEffect } from \"react\";\nimport {\n  CopilotContextParams,\n  CopilotMessagesContextParams,\n  useCopilotContext,\n  useCopilotMessagesContext,\n} from \"../context\";\nimport { CoagentState } from \"../types/coagent-state\";\nimport { useCopilotChat } from \"./use-copilot-chat\";\nimport { AgentStateMessage, Message, Role, TextMessage } from \"@copilotkit/runtime-client-gql\";\n\ninterface WithInternalStateManagementAndInitial<T> {\n  name: string;\n  initialState: T;\n}\n\ninterface WithInternalStateManagement {\n  name: string;\n  initialState?: any; // Optional initialState with default type any\n}\n\ninterface WithExternalStateManagement<T> {\n  name: string;\n  state: T;\n  setState: (newState: T | ((prevState: T | undefined) => T)) => void;\n}\n\ntype UseCoagentOptions<T> =\n  | WithInternalStateManagementAndInitial<T>\n  | WithInternalStateManagement\n  | WithExternalStateManagement<T>;\n\nexport interface UseCoagentReturnType<T> {\n  name: string;\n  nodeName?: string;\n  threadId?: string;\n  running: boolean;\n  state: T;\n  setState: (newState: T | ((prevState: T | undefined) => T)) => void;\n  start: () => void;\n  stop: () => void;\n  run: (hint?: HintFunction) => Promise<void>;\n}\n\nexport interface HintFunctionParams {\n  previousState: any;\n  currentState: any;\n}\n\nexport type HintFunction = (params: HintFunctionParams) => Message | undefined;\n\nexport function useCoAgent<T = any>(options: UseCoagentOptions<T>): UseCoagentReturnType<T> {\n  const isExternalStateManagement = (\n    options: UseCoagentOptions<T>,\n  ): options is WithExternalStateManagement<T> => {\n    return \"state\" in options && \"setState\" in options;\n  };\n\n  const { name } = options;\n\n  const isInternalStateManagementWithInitial = (\n    options: UseCoagentOptions<T>,\n  ): options is WithInternalStateManagementAndInitial<T> => {\n    return \"initialState\" in options;\n  };\n\n  const generalContext = useCopilotContext();\n  const messagesContext = useCopilotMessagesContext();\n  const context = { ...generalContext, ...messagesContext };\n  const { coagentStates, setCoagentStates } = context;\n  const { appendMessage } = useCopilotChat();\n\n  const getCoagentState = (coagentStates: Record<string, CoagentState>, name: string) => {\n    if (coagentStates[name]) {\n      return coagentStates[name];\n    } else {\n      return {\n        name,\n        state: isInternalStateManagementWithInitial(options) ? options.initialState : {},\n        running: false,\n        active: false,\n        threadId: undefined,\n        nodeName: undefined,\n        runId: undefined,\n      };\n    }\n  };\n\n  // if we manage state internally, we need to provide a function to set the state\n  const setState = (newState: T | ((prevState: T | undefined) => T)) => {\n    setCoagentStates((prevAgentStates) => {\n      let coagentState: CoagentState = getCoagentState(prevAgentStates, name);\n\n      const updatedState =\n        typeof newState === \"function\" ? (newState as Function)(coagentState.state) : newState;\n\n      return {\n        ...prevAgentStates,\n        [name]: {\n          ...coagentState,\n          state: updatedState,\n        },\n      };\n    });\n  };\n\n  const coagentState = getCoagentState(coagentStates, name);\n\n  const state = isExternalStateManagement(options) ? options.state : coagentState.state;\n\n  // Sync internal state with external state if state management is external\n  useEffect(() => {\n    if (isExternalStateManagement(options)) {\n      setState(options.state);\n    } else if (coagentStates[name] === undefined) {\n      setState(options.initialState === undefined ? {} : options.initialState);\n    }\n  }, [isExternalStateManagement(options) ? JSON.stringify(options.state) : undefined]);\n\n  // Return the state and setState function\n  return {\n    name,\n    nodeName: coagentState.nodeName,\n    state,\n    setState,\n    running: coagentState.running,\n    start: () => {\n      startAgent(name, context);\n    },\n    stop: () => {\n      stopAgent(name, context);\n    },\n    run: (hint?: HintFunction) => {\n      return runAgent(name, context, appendMessage, hint);\n    },\n  };\n}\n\nfunction startAgent(name: string, context: CopilotContextParams) {\n  const { setAgentSession } = context;\n  setAgentSession({\n    agentName: name,\n  });\n}\n\nfunction stopAgent(name: string, context: CopilotContextParams) {\n  const { agentSession, setAgentSession } = context;\n  if (agentSession && agentSession.agentName === name) {\n    setAgentSession(null);\n  } else {\n    console.warn(`No agent session found for ${name}`);\n  }\n}\n\nasync function runAgent(\n  name: string,\n  context: CopilotContextParams & CopilotMessagesContextParams,\n  appendMessage: (message: Message) => Promise<void>,\n  hint?: HintFunction,\n) {\n  const { agentSession, setAgentSession } = context;\n  if (!agentSession || agentSession.agentName !== name) {\n    setAgentSession({\n      agentName: name,\n    });\n  }\n\n  let previousState: any = null;\n  for (let i = context.messages.length - 1; i >= 0; i--) {\n    const message = context.messages[i];\n    if (message.isAgentStateMessage() && message.agentName === name) {\n      previousState = message.state;\n    }\n  }\n\n  let state = context.coagentStates?.[name]?.state || {};\n\n  if (hint) {\n    const hintMessage = hint({ previousState, currentState: state });\n    if (hintMessage) {\n      await appendMessage(hintMessage);\n    }\n  }\n}\n","/**\n * This class is used to execute one-off tasks, for example on button press. It can use the context available via [useCopilotReadable](/reference/hooks/useCopilotReadable) and the actions provided by [useCopilotAction](/reference/hooks/useCopilotAction), or you can provide your own context and actions.\n *\n * ## Example\n * In the simplest case, use CopilotTask in the context of your app by giving it instructions on what to do.\n *\n * ```tsx\n * import { CopilotTask, useCopilotContext } from \"@copilotkit/react-core\";\n *\n * export function MyComponent() {\n *   const context = useCopilotContext();\n *\n *   const task = new CopilotTask({\n *     instructions: \"Set a random message\",\n *     actions: [\n *       {\n *         name: \"setMessage\",\n *       description: \"Set the message.\",\n *       argumentAnnotations: [\n *         {\n *           name: \"message\",\n *           type: \"string\",\n *           description:\n *             \"A message to display.\",\n *           required: true,\n *         },\n *       ],\n *\n *       implementation: async (message) => {\n *         // ...\n *       },\n *     }\n *     ]\n *   });\n *\n *   const executeTask = async () => {\n *     await task.run(context, action);\n *   }\n *\n *   return (\n *     <>\n *       <button onClick={executeTask}>\n *         Execute task\n *       </button>\n *     </>\n *   )\n * }\n * ```\n *\n * Have a look at the [Presentation Example App](https://github.com/CopilotKit/CopilotKit/blob/main/CopilotKit/examples/next-openai/src/app/presentation/page.tsx) for a more complete example.\n */\n\nimport {\n  ActionExecutionMessage,\n  CopilotRuntimeClient,\n  Message,\n  Role,\n  TextMessage,\n  convertGqlOutputToMessages,\n  convertMessagesToGqlInput,\n  filterAgentStateMessages,\n  CopilotRequestType,\n} from \"@copilotkit/runtime-client-gql\";\nimport { FrontendAction } from \"../types/frontend-action\";\nimport { CopilotContextParams } from \"../context\";\nimport { defaultCopilotContextCategories } from \"../components\";\nimport { MessageStatusCode } from \"@copilotkit/runtime-client-gql\";\nimport { actionParametersToJsonSchema } from \"@copilotkit/shared\";\n\nexport interface CopilotTaskConfig {\n  /**\n   * The instructions to be given to the assistant.\n   */\n  instructions: string;\n  /**\n   * An array of action definitions that can be called.\n   */\n  actions?: FrontendAction<any>[];\n  /**\n   * Whether to include the copilot readable context in the task.\n   */\n  includeCopilotReadable?: boolean;\n\n  /**\n   * Whether to include actions defined via useCopilotAction in the task.\n   */\n  includeCopilotActions?: boolean;\n}\n\nexport class CopilotTask<T = any> {\n  private instructions: string;\n  private actions: FrontendAction<any>[];\n  private includeCopilotReadable: boolean;\n  private includeCopilotActions: boolean;\n\n  constructor(config: CopilotTaskConfig) {\n    this.instructions = config.instructions;\n    this.actions = config.actions || [];\n    this.includeCopilotReadable = config.includeCopilotReadable !== false;\n    this.includeCopilotActions = config.includeCopilotActions !== false;\n  }\n\n  /**\n   * Run the task.\n   * @param context The CopilotContext to use for the task. Use `useCopilotContext` to obtain the current context.\n   * @param data The data to use for the task.\n   */\n  async run(context: CopilotContextParams, data?: T): Promise<void> {\n    const actions = this.includeCopilotActions ? Object.assign({}, context.actions) : {};\n\n    // merge functions into entry points\n    for (const fn of this.actions) {\n      actions[fn.name] = fn;\n    }\n\n    let contextString = \"\";\n\n    if (data) {\n      contextString = (typeof data === \"string\" ? data : JSON.stringify(data)) + \"\\n\\n\";\n    }\n\n    if (this.includeCopilotReadable) {\n      contextString += context.getContextString([], defaultCopilotContextCategories);\n    }\n\n    const systemMessage = new TextMessage({\n      content: taskSystemMessage(contextString, this.instructions),\n      role: Role.System,\n    });\n\n    const messages: Message[] = [systemMessage];\n\n    const runtimeClient = new CopilotRuntimeClient({\n      url: context.copilotApiConfig.chatApiEndpoint,\n      publicApiKey: context.copilotApiConfig.publicApiKey,\n      headers: context.copilotApiConfig.headers,\n      credentials: context.copilotApiConfig.credentials,\n    });\n\n    const response = await runtimeClient\n      .generateCopilotResponse({\n        data: {\n          frontend: {\n            actions: Object.values(actions).map((action) => ({\n              name: action.name,\n              description: action.description || \"\",\n              jsonSchema: JSON.stringify(actionParametersToJsonSchema(action.parameters || [])),\n            })),\n            url: window.location.href,\n          },\n          messages: convertMessagesToGqlInput(filterAgentStateMessages(messages)),\n          metadata: {\n            requestType: CopilotRequestType.Task,\n          },\n          forwardedParameters: {\n            toolChoice: \"required\",\n          },\n        },\n        properties: context.copilotApiConfig.properties,\n      })\n      .toPromise();\n\n    const functionCallHandler = context.getFunctionCallHandler(actions);\n    const functionCalls = convertGqlOutputToMessages(\n      response.data?.generateCopilotResponse?.messages || [],\n    ).filter((m): m is ActionExecutionMessage => m.isActionExecutionMessage());\n\n    for (const functionCall of functionCalls) {\n      await functionCallHandler({\n        messages,\n        name: functionCall.name,\n        args: functionCall.arguments,\n      });\n    }\n  }\n}\n\nfunction taskSystemMessage(contextString: string, instructions: string): string {\n  return `\nPlease act as an efficient, competent, conscientious, and industrious professional assistant.\n\nHelp the user achieve their goals, and you do so in a way that is as efficient as possible, without unnecessary fluff, but also without sacrificing professionalism.\nAlways be polite and respectful, and prefer brevity over verbosity.\n\nThe user has provided you with the following context:\n\\`\\`\\`\n${contextString}\n\\`\\`\\`\n\nThey have also provided you with functions you can call to initiate actions on their behalf.\n\nPlease assist them as best you can.\n\nThis is not a conversation, so please do not ask questions. Just call a function without saying anything else.\n\nThe user has given you the following task to complete:\n\n\\`\\`\\`\n${instructions}\n\\`\\`\\`\n`;\n}\n","import {\n  Action,\n  COPILOT_CLOUD_PUBLIC_API_KEY_HEADER,\n  MappedParameterTypes,\n  Parameter,\n  actionParametersToJsonSchema,\n} from \"@copilotkit/shared\";\nimport {\n  ActionExecutionMessage,\n  Message,\n  Role,\n  TextMessage,\n  convertGqlOutputToMessages,\n  CopilotRequestType,\n} from \"@copilotkit/runtime-client-gql\";\nimport { CopilotContextParams, CopilotMessagesContextParams } from \"../context\";\nimport { defaultCopilotContextCategories } from \"../components\";\nimport { CopilotRuntimeClient } from \"@copilotkit/runtime-client-gql\";\nimport {\n  convertMessagesToGqlInput,\n  filterAgentStateMessages,\n} from \"@copilotkit/runtime-client-gql\";\n\ninterface InitialState<T extends Parameter[] | [] = []> {\n  status: \"initial\";\n  args: Partial<MappedParameterTypes<T>>;\n}\n\ninterface InProgressState<T extends Parameter[] | [] = []> {\n  status: \"inProgress\";\n  args: Partial<MappedParameterTypes<T>>;\n}\n\ninterface CompleteState<T extends Parameter[] | [] = []> {\n  status: \"complete\";\n  args: MappedParameterTypes<T>;\n}\n\ntype StreamHandlerArgs<T extends Parameter[] | [] = []> =\n  | InitialState<T>\n  | InProgressState<T>\n  | CompleteState<T>;\n\ninterface ExtractOptions<T extends Parameter[]> {\n  context: CopilotContextParams & CopilotMessagesContextParams;\n  instructions: string;\n  parameters: T;\n  include?: IncludeOptions;\n  data?: any;\n  abortSignal?: AbortSignal;\n  stream?: (args: StreamHandlerArgs<T>) => void;\n  requestType?: CopilotRequestType;\n}\n\ninterface IncludeOptions {\n  readable?: boolean;\n  messages?: boolean;\n}\n\nexport async function extract<const T extends Parameter[]>({\n  context,\n  instructions,\n  parameters,\n  include,\n  data,\n  abortSignal,\n  stream,\n  requestType = CopilotRequestType.Task,\n}: ExtractOptions<T>): Promise<MappedParameterTypes<T>> {\n  const { messages } = context;\n\n  const action: Action<any> = {\n    name: \"extract\",\n    description: instructions,\n    parameters,\n    handler: (args: any) => {},\n  };\n\n  const includeReadable = include?.readable ?? false;\n  const includeMessages = include?.messages ?? false;\n\n  let contextString = \"\";\n\n  if (data) {\n    contextString = (typeof data === \"string\" ? data : JSON.stringify(data)) + \"\\n\\n\";\n  }\n\n  if (includeReadable) {\n    contextString += context.getContextString([], defaultCopilotContextCategories);\n  }\n\n  const systemMessage: Message = new TextMessage({\n    content: makeSystemMessage(contextString, instructions),\n    role: Role.System,\n  });\n\n  const instructionsMessage: Message = new TextMessage({\n    content: makeInstructionsMessage(instructions),\n    role: Role.User,\n  });\n\n  const headers = {\n    ...(context.copilotApiConfig.headers || {}),\n    ...(context.copilotApiConfig.publicApiKey\n      ? { [COPILOT_CLOUD_PUBLIC_API_KEY_HEADER]: context.copilotApiConfig.publicApiKey }\n      : {}),\n  };\n\n  const runtimeClient = new CopilotRuntimeClient({\n    url: context.copilotApiConfig.chatApiEndpoint,\n    publicApiKey: context.copilotApiConfig.publicApiKey,\n    headers,\n    credentials: context.copilotApiConfig.credentials,\n  });\n\n  const response = CopilotRuntimeClient.asStream(\n    runtimeClient.generateCopilotResponse({\n      data: {\n        frontend: {\n          actions: [\n            {\n              name: action.name,\n              description: action.description || \"\",\n              jsonSchema: JSON.stringify(actionParametersToJsonSchema(action.parameters || [])),\n            },\n          ],\n          url: window.location.href,\n        },\n\n        messages: convertMessagesToGqlInput(\n          includeMessages\n            ? [systemMessage, instructionsMessage, ...filterAgentStateMessages(messages)]\n            : [systemMessage, instructionsMessage],\n        ),\n        metadata: {\n          requestType: requestType,\n        },\n        forwardedParameters: {\n          toolChoice: \"function\",\n          toolChoiceFunctionName: action.name,\n        },\n      },\n      properties: context.copilotApiConfig.properties,\n      signal: abortSignal,\n    }),\n  );\n\n  const reader = response.getReader();\n\n  let isInitial = true;\n\n  let actionExecutionMessage: ActionExecutionMessage | undefined = undefined;\n\n  while (true) {\n    const { done, value } = await reader.read();\n\n    if (done) {\n      break;\n    }\n\n    if (abortSignal?.aborted) {\n      throw new Error(\"Aborted\");\n    }\n\n    actionExecutionMessage = convertGqlOutputToMessages(\n      value.generateCopilotResponse.messages,\n    ).find((msg) => msg.isActionExecutionMessage()) as ActionExecutionMessage | undefined;\n\n    if (!actionExecutionMessage) {\n      continue;\n    }\n\n    stream?.({\n      status: isInitial ? \"initial\" : \"inProgress\",\n      args: actionExecutionMessage.arguments as Partial<MappedParameterTypes<T>>,\n    });\n\n    isInitial = false;\n  }\n\n  if (!actionExecutionMessage) {\n    throw new Error(\"extract() failed: No function call occurred\");\n  }\n\n  stream?.({\n    status: \"complete\",\n    args: actionExecutionMessage.arguments as MappedParameterTypes<T>,\n  });\n\n  return actionExecutionMessage.arguments as MappedParameterTypes<T>;\n}\n\n// We need to put this in a user message since some LLMs need\n// at least one user message to function\nfunction makeInstructionsMessage(instructions: string): string {\n  return `\nThe user has given you the following task to complete:\n\n\\`\\`\\`\n${instructions}\n\\`\\`\\`\n\nAny additional messages provided are for providing context only and should not be used to ask questions or engage in conversation.\n`;\n}\n\nfunction makeSystemMessage(contextString: string, instructions: string): string {\n  return `\nPlease act as an efficient, competent, conscientious, and industrious professional assistant.\n\nHelp the user achieve their goals, and you do so in a way that is as efficient as possible, without unnecessary fluff, but also without sacrificing professionalism.\nAlways be polite and respectful, and prefer brevity over verbosity.\n\nThe user has provided you with the following context:\n\\`\\`\\`\n${contextString}\n\\`\\`\\`\n\nThey have also provided you with a function called extract you MUST call to initiate actions on their behalf.\n\nPlease assist them as best you can.\n\nThis is not a conversation, so please do not ask questions. Just call the function without saying anything else.\n`;\n}\n"],"mappings":"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","names":["import_react","React","import_react","import_shared","import_react","import_shared","setsHaveIntersection","import_react","import_react","emptyCopilotContext","React","import_jsx_runtime","_a","_b","action","import_react","import_runtime_client_gql","import_react","import_shared","messages","action","makeSystemMessage","_a","action","messages","import_react","import_shared","import_react","import_shared","import_react","import_react","import_react","options","coagentStates","name","coagentState","import_runtime_client_gql","import_shared","import_shared","import_runtime_client_gql","import_runtime_client_gql"]}