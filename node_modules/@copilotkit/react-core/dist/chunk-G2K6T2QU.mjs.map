{"version":3,"sources":["../src/hooks/use-chat.ts"],"sourcesContent":["import { useRef } from \"react\";\nimport {\n  FunctionCallHandler,\n  COPILOT_CLOUD_PUBLIC_API_KEY_HEADER,\n  actionParametersToJsonSchema,\n  CoAgentStateRenderHandler,\n} from \"@copilotkit/shared\";\nimport {\n  Message,\n  TextMessage,\n  ActionExecutionMessage,\n  ResultMessage,\n  CopilotRuntimeClient,\n  convertMessagesToGqlInput,\n  filterAdjacentAgentStateMessages,\n  filterAgentStateMessages,\n  convertGqlOutputToMessages,\n  MessageStatusCode,\n  MessageRole,\n  Role,\n  CopilotRequestType,\n  AgentStateMessage,\n} from \"@copilotkit/runtime-client-gql\";\n\nimport { CopilotApiConfig } from \"../context\";\nimport { FrontendAction } from \"../types/frontend-action\";\nimport { CoagentState } from \"../types/coagent-state\";\nimport { AgentSession } from \"../context/copilot-context\";\n\nexport type UseChatOptions = {\n  /**\n   * System messages of the chat. Defaults to an empty array.\n   */\n  initialMessages?: Message[];\n  /**\n   * Callback function to be called when a function call is received.\n   * If the function returns a `ChatRequest` object, the request will be sent\n   * automatically to the API and will be used to update the chat.\n   */\n  onFunctionCall?: FunctionCallHandler;\n\n  /**\n   * Callback function to be called when a coagent action is received.\n   */\n  onCoAgentStateRender?: CoAgentStateRenderHandler;\n\n  /**\n   * Function definitions to be sent to the API.\n   */\n  actions: FrontendAction<any>[];\n\n  /**\n   * The CopilotKit API configuration.\n   */\n  copilotConfig: CopilotApiConfig;\n\n  /**\n   * The current list of messages in the chat.\n   */\n  messages: Message[];\n  /**\n   * The setState-powered method to update the chat messages.\n   */\n  setMessages: React.Dispatch<React.SetStateAction<Message[]>>;\n\n  /**\n   * A callback to get the latest system message.\n   */\n  makeSystemMessageCallback: () => TextMessage;\n\n  /**\n   * Whether the API request is in progress\n   */\n  isLoading: boolean;\n\n  /**\n   * setState-powered method to update the isChatLoading value\n   */\n  setIsLoading: React.Dispatch<React.SetStateAction<boolean>>;\n\n  /**\n   * The current list of coagent states.\n   */\n  coagentStates: Record<string, CoagentState>;\n\n  /**\n   * setState-powered method to update the agent states\n   */\n  setCoagentStates: React.Dispatch<React.SetStateAction<Record<string, CoagentState>>>;\n\n  /**\n   * The current agent session.\n   */\n  agentSession: AgentSession | null;\n\n  /**\n   * setState-powered method to update the agent session\n   */\n  setAgentSession: React.Dispatch<React.SetStateAction<AgentSession | null>>;\n};\n\nexport type UseChatHelpers = {\n  /**\n   * Append a user message to the chat list. This triggers the API call to fetch\n   * the assistant's response.\n   * @param message The message to append\n   */\n  append: (message: Message) => Promise<void>;\n  /**\n   * Reload the last AI chat response for the given chat history. If the last\n   * message isn't from the assistant, it will request the API to generate a\n   * new response.\n   */\n  reload: () => Promise<void>;\n  /**\n   * Abort the current request immediately, keep the generated tokens if any.\n   */\n  stop: () => void;\n};\n\nexport function useChat(options: UseChatOptions): UseChatHelpers {\n  const {\n    messages,\n    setMessages,\n    makeSystemMessageCallback,\n    copilotConfig,\n    setIsLoading,\n    initialMessages,\n    isLoading,\n    actions,\n    onFunctionCall,\n    onCoAgentStateRender,\n    setCoagentStates,\n    coagentStates,\n    agentSession,\n    setAgentSession,\n  } = options;\n\n  const abortControllerRef = useRef<AbortController>();\n  const threadIdRef = useRef<string | null>(null);\n  const runIdRef = useRef<string | null>(null);\n\n  const runChatCompletionRef = useRef<(previousMessages: Message[]) => Promise<Message[]>>();\n  // We need to keep a ref of coagent states because of renderAndWait - making sure\n  // the latest state is sent to the API\n  // This is a workaround and needs to be addressed in the future\n  const coagentStatesRef = useRef<Record<string, CoagentState>>(coagentStates);\n  coagentStatesRef.current = coagentStates;\n  const agentSessionRef = useRef<AgentSession | null>(agentSession);\n  agentSessionRef.current = agentSession;\n\n  const publicApiKey = copilotConfig.publicApiKey;\n\n  const headers = {\n    ...(copilotConfig.headers || {}),\n    ...(publicApiKey ? { [COPILOT_CLOUD_PUBLIC_API_KEY_HEADER]: publicApiKey } : {}),\n  };\n\n  const runtimeClient = new CopilotRuntimeClient({\n    url: copilotConfig.chatApiEndpoint,\n    publicApiKey: copilotConfig.publicApiKey,\n    headers,\n    credentials: copilotConfig.credentials,\n  });\n\n  const runChatCompletion = async (previousMessages: Message[]): Promise<Message[]> => {\n    setIsLoading(true);\n\n    // this message is just a placeholder. It will disappear once the first real message\n    // is received\n    let newMessages: Message[] = [\n      new TextMessage({\n        content: \"\",\n        role: Role.Assistant,\n      }),\n    ];\n    const abortController = new AbortController();\n    abortControllerRef.current = abortController;\n\n    setMessages([...previousMessages, ...newMessages]);\n\n    const systemMessage = makeSystemMessageCallback();\n\n    const messagesWithContext = [systemMessage, ...(initialMessages || []), ...previousMessages];\n\n    const stream = CopilotRuntimeClient.asStream(\n      runtimeClient.generateCopilotResponse({\n        data: {\n          frontend: {\n            actions: actions\n              .filter((action) => !action.disabled)\n              .map((action) => ({\n                name: action.name,\n                description: action.description || \"\",\n                jsonSchema: JSON.stringify(actionParametersToJsonSchema(action.parameters || [])),\n              })),\n            url: window.location.href,\n          },\n          threadId: threadIdRef.current,\n          runId: runIdRef.current,\n          messages: convertMessagesToGqlInput(filterAgentStateMessages(messagesWithContext)),\n          ...(copilotConfig.cloud\n            ? {\n                cloud: {\n                  ...(copilotConfig.cloud.guardrails?.input?.restrictToTopic?.enabled\n                    ? {\n                        guardrails: {\n                          inputValidationRules: {\n                            allowList:\n                              copilotConfig.cloud.guardrails.input.restrictToTopic.validTopics,\n                            denyList:\n                              copilotConfig.cloud.guardrails.input.restrictToTopic.invalidTopics,\n                          },\n                        },\n                      }\n                    : {}),\n                },\n              }\n            : {}),\n          metadata: {\n            requestType: CopilotRequestType.Chat,\n          },\n          ...(agentSessionRef.current\n            ? {\n                agentSession: agentSessionRef.current,\n              }\n            : {}),\n          agentStates: Object.values(coagentStatesRef.current).map((state) => ({\n            agentName: state.name,\n            state: JSON.stringify(state.state),\n          })),\n        },\n        properties: copilotConfig.properties,\n        signal: abortControllerRef.current?.signal,\n      }),\n    );\n\n    const guardrailsEnabled =\n      copilotConfig.cloud?.guardrails?.input?.restrictToTopic.enabled || false;\n\n    const reader = stream.getReader();\n\n    let actionResults: { [id: string]: string } = {};\n    let executedCoAgentStateRenders: string[] = [];\n    let followUp: FrontendAction[\"followUp\"] = undefined;\n\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n\n        if (done) {\n          break;\n        }\n\n        if (!value?.generateCopilotResponse) {\n          continue;\n        }\n\n        threadIdRef.current = value.generateCopilotResponse.threadId || null;\n        runIdRef.current = value.generateCopilotResponse.runId || null;\n\n        const messages = convertGqlOutputToMessages(\n          filterAdjacentAgentStateMessages(value.generateCopilotResponse.messages),\n        );\n\n        if (messages.length === 0) {\n          continue;\n        }\n\n        newMessages = [];\n\n        // request failed, display error message\n        if (\n          value.generateCopilotResponse.status?.__typename === \"FailedResponseStatus\" &&\n          value.generateCopilotResponse.status.reason === \"GUARDRAILS_VALIDATION_FAILED\"\n        ) {\n          newMessages = [\n            new TextMessage({\n              role: MessageRole.Assistant,\n              content: value.generateCopilotResponse.status.details?.guardrailsReason || \"\",\n            }),\n          ];\n        }\n\n        // add messages to the chat\n        else {\n          for (const message of messages) {\n            newMessages.push(message);\n            // execute regular action executions\n            if (\n              message.isActionExecutionMessage() &&\n              message.status.code !== MessageStatusCode.Pending &&\n              message.scope === \"client\" &&\n              onFunctionCall\n            ) {\n              if (!(message.id in actionResults)) {\n                // Do not execute a function call if guardrails are enabled but the status is not known\n                if (guardrailsEnabled && value.generateCopilotResponse.status === undefined) {\n                  break;\n                }\n                // execute action\n                try {\n                  // We update the message state before calling the handler so that the render\n                  // function can be called with `executing` state\n                  setMessages([...previousMessages, ...newMessages]);\n\n                  const action = actions.find((action) => action.name === message.name);\n\n                  if (action) {\n                    followUp = action.followUp;\n                  }\n\n                  const result = await onFunctionCall({\n                    messages: previousMessages,\n                    name: message.name,\n                    args: message.arguments,\n                  });\n                  actionResults[message.id] = result;\n                } catch (e) {\n                  actionResults[message.id] = `Failed to execute action ${message.name}`;\n                  console.error(`Failed to execute action ${message.name}: ${e}`);\n                }\n              }\n              // add the result message\n              newMessages.push(\n                new ResultMessage({\n                  result: ResultMessage.encodeResult(actionResults[message.id]),\n                  actionExecutionId: message.id,\n                  actionName: message.name,\n                }),\n              );\n            }\n            // execute coagent actions\n            if (\n              message.isAgentStateMessage() &&\n              !message.active &&\n              !executedCoAgentStateRenders.includes(message.id) &&\n              onCoAgentStateRender\n            ) {\n              // Do not execute a coagent action if guardrails are enabled but the status is not known\n              if (guardrailsEnabled && value.generateCopilotResponse.status === undefined) {\n                break;\n              }\n              // execute coagent action\n              await onCoAgentStateRender({\n                name: message.agentName,\n                nodeName: message.nodeName,\n                state: message.state,\n              });\n              executedCoAgentStateRenders.push(message.id);\n            }\n          }\n\n          const lastAgentStateMessage = [...messages]\n            .reverse()\n            .find((message) => message.isAgentStateMessage());\n\n          if (lastAgentStateMessage) {\n            setCoagentStates((prevAgentStates) => ({\n              ...prevAgentStates,\n              [lastAgentStateMessage.agentName]: {\n                name: lastAgentStateMessage.agentName,\n                state: lastAgentStateMessage.state,\n                running: lastAgentStateMessage.running,\n                active: lastAgentStateMessage.active,\n                threadId: lastAgentStateMessage.threadId,\n                nodeName: lastAgentStateMessage.nodeName,\n                runId: lastAgentStateMessage.runId,\n              },\n            }));\n            if (lastAgentStateMessage.running) {\n              setAgentSession({\n                threadId: lastAgentStateMessage.threadId,\n                agentName: lastAgentStateMessage.agentName,\n                nodeName: lastAgentStateMessage.nodeName,\n              });\n            } else {\n              setAgentSession(null);\n            }\n          }\n        }\n\n        if (newMessages.length > 0) {\n          // Update message state\n          setMessages([...previousMessages, ...newMessages]);\n        }\n      }\n\n      if (\n        // if followUp is not explicitly false\n        followUp !== false &&\n        // if we have client side results\n        (Object.values(actionResults).length ||\n          // or the last message we received is a result\n          (newMessages.length && newMessages[newMessages.length - 1].isResultMessage()))\n      ) {\n        // run the completion again and return the result\n\n        // wait for next tick to make sure all the react state updates\n        // - tried using react-dom's flushSync, but it did not work\n        await new Promise((resolve) => setTimeout(resolve, 10));\n\n        return await runChatCompletionRef.current!([...previousMessages, ...newMessages]);\n      } else {\n        return newMessages.slice();\n      }\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  runChatCompletionRef.current = runChatCompletion;\n\n  const runChatCompletionAndHandleFunctionCall = async (messages: Message[]): Promise<void> => {\n    await runChatCompletionRef.current!(messages);\n  };\n\n  const append = async (message: Message): Promise<void> => {\n    if (isLoading) {\n      return;\n    }\n\n    const newMessages = [...messages, message];\n    setMessages(newMessages);\n    return runChatCompletionAndHandleFunctionCall(newMessages);\n  };\n\n  const reload = async (): Promise<void> => {\n    if (isLoading || messages.length === 0) {\n      return;\n    }\n    let newMessages = [...messages];\n    const lastMessage = messages[messages.length - 1];\n\n    if (lastMessage.isTextMessage() && lastMessage.role === \"assistant\") {\n      newMessages = newMessages.slice(0, -1);\n    }\n\n    setMessages(newMessages);\n\n    return runChatCompletionAndHandleFunctionCall(newMessages);\n  };\n\n  const stop = (): void => {\n    abortControllerRef.current?.abort();\n  };\n\n  return {\n    append,\n    reload,\n    stop,\n  };\n}\n"],"mappings":"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","names":["messages","action"]}