{"version":3,"sources":["../../src/types/action.ts"],"sourcesContent":["type TypeMap = {\n  string: string;\n  number: number;\n  boolean: boolean;\n  object: object;\n  \"string[]\": string[];\n  \"number[]\": number[];\n  \"boolean[]\": boolean[];\n  \"object[]\": object[];\n};\n\ntype AbstractParameter = {\n  name: string;\n  type?: keyof TypeMap;\n  description?: string;\n  required?: boolean;\n};\n\ninterface StringParameter extends AbstractParameter {\n  type: \"string\";\n  enum?: string[];\n}\n\ninterface ObjectParameter extends AbstractParameter {\n  type: \"object\";\n  attributes?: Parameter[];\n}\n\ninterface ObjectArrayParameter extends AbstractParameter {\n  type: \"object[]\";\n  attributes?: Parameter[];\n}\n\ntype SpecialParameters = StringParameter | ObjectParameter | ObjectArrayParameter;\ninterface BaseParameter extends AbstractParameter {\n  type?: Exclude<AbstractParameter[\"type\"], SpecialParameters[\"type\"]>;\n}\n\nexport type Parameter = BaseParameter | SpecialParameters;\n\ntype OptionalParameterType<P extends AbstractParameter> = P[\"required\"] extends false\n  ? undefined\n  : never;\n\ntype StringParameterType<P> = P extends StringParameter\n  ? P extends { enum?: Array<infer E> }\n    ? E\n    : string\n  : never;\n\ntype ObjectParameterType<P> = P extends ObjectParameter\n  ? P extends { attributes?: infer Attributes extends Parameter[] }\n    ? MappedParameterTypes<Attributes>\n    : object\n  : never;\n\ntype ObjectArrayParameterType<P> = P extends ObjectArrayParameter\n  ? P extends { attributes?: infer Attributes extends Parameter[] }\n    ? MappedParameterTypes<Attributes>[]\n    : any[]\n  : never;\n\ntype MappedTypeOrString<T> = T extends keyof TypeMap ? TypeMap[T] : string;\ntype BaseParameterType<P extends AbstractParameter> = P extends { type: infer T }\n  ? T extends BaseParameter[\"type\"]\n    ? MappedTypeOrString<T>\n    : never\n  : string;\n\nexport type MappedParameterTypes<T extends Parameter[] | [] = []> = T extends []\n  ? Record<string, any>\n  : {\n      [P in T[number] as P[\"name\"]]:\n        | OptionalParameterType<P>\n        | StringParameterType<P>\n        | ObjectParameterType<P>\n        | ObjectArrayParameterType<P>\n        | BaseParameterType<P>;\n    };\n\nexport type Action<T extends Parameter[] | [] = []> = {\n  name: string;\n  description?: string;\n  parameters?: T;\n  handler?: T extends []\n    ? () => any | Promise<any>\n    : (args: MappedParameterTypes<T>) => any | Promise<any>;\n};\n\n// This is the original \"ceiling is being raised\" version of MappedParameterTypes.\n//\n// ceiling is being raised. cursor's copilot helped us write \"superhuman code\"\n// for a critical feature. We can read this code, but VERY few engineers out\n// there could write it from scratch.\n// Took lots of convincing too. \"come on, this must be possible, try harder\".\n// and obviously- done in parts.\n//\n// - https://twitter.com/ataiiam/status/1765089261374914957\n//   (Mar 5, 2024)\n//\n// export type MappedParameterTypes<T extends Parameter[]> = {\n//   // Check if the parameter has an 'enum' defined\n//   [P in T[number] as P[\"name\"]]: P extends { enum: Array<infer E> }\n//     ? E extends string // Ensure the enum values are strings\n//       ? P[\"required\"] extends false // Check if the parameter is optional\n//         ? E | undefined // If so, include 'undefined' in the type\n//         : E // Otherwise, use the enum type directly\n//       : never // This case should not occur since 'enum' implies string values\n//     : // Handle parameters defined as 'object' with specified attributes\n//     P extends { type: \"object\"; attributes: infer Attributes }\n//     ? Attributes extends Parameter[]\n//       ? MappedParameterTypes<Attributes> // Recursively map the attributes of the object\n//       : never // If 'attributes' is not an array of Parameters, this is invalid\n//     : // Handle parameters defined as 'object[]' without specified attributes\n//     P extends { type: \"object[]\"; attributes?: never }\n//     ? any[] // Default to 'any[]' for arrays of objects without specific attributes\n//     : // Handle parameters defined as 'object[]' with specified attributes\n//     P extends { type: \"object[]\"; attributes: infer Attributes }\n//     ? Attributes extends Parameter[]\n//       ? MappedParameterTypes<Attributes>[] // Recursively map each object in the array\n//       : any[] // Default to 'any[]' if attributes are not properly defined\n//     : // Handle all other parameter types\n//     P[\"required\"] extends false\n//     ? // Include 'undefined' for optional parameters\n//       TypeMap[P[\"type\"] extends keyof TypeMap ? P[\"type\"] : \"string\"] | undefined\n//     : // Use the direct mapping from 'TypeMap' for the parameter's type\n//       TypeMap[P[\"type\"] extends keyof TypeMap ? P[\"type\"] : \"string\"];\n// };\n"],"mappings":";;;;;;;;;;;;;;;;AAAA;AAAA;","names":[]}