{"version":3,"sources":["../src/lib/runtime/copilot-runtime.ts","../src/service-adapters/conversion.ts"],"sourcesContent":["/**\n * <Callout type=\"info\">\n *   This is the reference for the `CopilotRuntime` class. For more information and example code snippets, please see [Concept: Copilot Runtime](/concepts/copilot-runtime).\n * </Callout>\n *\n * ## Usage\n *\n * ```tsx\n * import { CopilotRuntime } from \"@copilotkit/runtime\";\n *\n * const copilotKit = new CopilotRuntime();\n * ```\n */\n\nimport { Action, actionParametersToJsonSchema, Parameter, randomId } from \"@copilotkit/shared\";\nimport { RemoteChain, RemoteChainParameters, CopilotServiceAdapter } from \"../../service-adapters\";\nimport { MessageInput } from \"../../graphql/inputs/message.input\";\nimport { ActionInput } from \"../../graphql/inputs/action.input\";\nimport { RuntimeEventSource } from \"../../service-adapters/events\";\nimport { convertGqlInputToMessages } from \"../../service-adapters/conversion\";\nimport { AgentStateMessage, Message } from \"../../graphql/types/converted\";\nimport { ForwardedParametersInput } from \"../../graphql/inputs/forwarded-parameters.input\";\nimport {\n  setupRemoteActions,\n  RemoteActionDefinition,\n  LangGraphAgentAction,\n  isLangGraphAgentAction,\n} from \"./remote-actions\";\nimport { GraphQLContext } from \"../integrations/shared\";\nimport { AgentSessionInput } from \"../../graphql/inputs/agent-session.input\";\nimport { from } from \"rxjs\";\nimport { AgentStateInput } from \"../../graphql/inputs/agent-state.input\";\n\ninterface CopilotRuntimeRequest {\n  serviceAdapter: CopilotServiceAdapter;\n  messages: MessageInput[];\n  actions: ActionInput[];\n  agentSession?: AgentSessionInput;\n  agentStates?: AgentStateInput[];\n  outputMessagesPromise: Promise<Message[]>;\n  threadId?: string;\n  runId?: string;\n  publicApiKey?: string;\n  graphqlContext: GraphQLContext;\n  forwardedParameters?: ForwardedParametersInput;\n  url?: string;\n}\n\ninterface CopilotRuntimeResponse {\n  threadId: string;\n  runId?: string;\n  eventSource: RuntimeEventSource;\n  serverSideActions: Action<any>[];\n  actionInputsWithoutAgents: ActionInput[];\n}\n\ntype ActionsConfiguration<T extends Parameter[] | [] = []> =\n  | Action<T>[]\n  | ((ctx: { properties: any; url?: string }) => Action<T>[]);\n\ninterface OnBeforeRequestOptions {\n  threadId?: string;\n  runId?: string;\n  inputMessages: Message[];\n  properties: any;\n  url?: string;\n}\n\ntype OnBeforeRequestHandler = (options: OnBeforeRequestOptions) => void | Promise<void>;\n\ninterface OnAfterRequestOptions {\n  threadId: string;\n  runId?: string;\n  inputMessages: Message[];\n  outputMessages: Message[];\n  properties: any;\n  url?: string;\n}\n\ntype OnAfterRequestHandler = (options: OnAfterRequestOptions) => void | Promise<void>;\n\ninterface Middleware {\n  /**\n   * A function that is called before the request is processed.\n   */\n  onBeforeRequest?: OnBeforeRequestHandler;\n\n  /**\n   * A function that is called after the request is processed.\n   */\n  onAfterRequest?: OnAfterRequestHandler;\n}\n\nexport interface CopilotRuntimeConstructorParams<T extends Parameter[] | [] = []> {\n  /**\n   * Middleware to be used by the runtime.\n   *\n   * ```ts\n   * onBeforeRequest: (options: {\n   *   threadId?: string;\n   *   runId?: string;\n   *   inputMessages: Message[];\n   *   properties: any;\n   * }) => void | Promise<void>;\n   * ```\n   *\n   * ```ts\n   * onAfterRequest: (options: {\n   *   threadId?: string;\n   *   runId?: string;\n   *   inputMessages: Message[];\n   *   outputMessages: Message[];\n   *   properties: any;\n   * }) => void | Promise<void>;\n   * ```\n   */\n  middleware?: Middleware;\n\n  /*\n   * A list of server side actions that can be executed.\n   */\n  actions?: ActionsConfiguration<T>;\n\n  /*\n   * A list of remote actions that can be executed.\n   */\n  remoteActions?: RemoteActionDefinition[];\n\n  /*\n   * An array of LangServer URLs.\n   */\n  langserve?: RemoteChainParameters[];\n}\n\nexport class CopilotRuntime<const T extends Parameter[] | [] = []> {\n  public actions: ActionsConfiguration<T>;\n  private remoteActionDefinitions: RemoteActionDefinition[];\n  private langserve: Promise<Action<any>>[] = [];\n  private onBeforeRequest?: OnBeforeRequestHandler;\n  private onAfterRequest?: OnAfterRequestHandler;\n\n  constructor(params?: CopilotRuntimeConstructorParams<T>) {\n    this.actions = params?.actions || [];\n\n    for (const chain of params?.langserve || []) {\n      const remoteChain = new RemoteChain(chain);\n      this.langserve.push(remoteChain.toAction());\n    }\n\n    this.remoteActionDefinitions = params?.remoteActions || [];\n\n    this.onBeforeRequest = params?.middleware?.onBeforeRequest;\n    this.onAfterRequest = params?.middleware?.onAfterRequest;\n  }\n\n  async processRuntimeRequest(request: CopilotRuntimeRequest): Promise<CopilotRuntimeResponse> {\n    const {\n      serviceAdapter,\n      messages: rawMessages,\n      actions: clientSideActionsInput,\n      threadId,\n      runId,\n      outputMessagesPromise,\n      graphqlContext,\n      forwardedParameters,\n      agentSession,\n      url,\n    } = request;\n\n    if (agentSession) {\n      return this.processAgentRequest(request);\n    }\n\n    const messages = rawMessages.filter((message) => !message.agentStateMessage);\n\n    const inputMessages = convertGqlInputToMessages(messages);\n    const serverSideActions = await this.getServerSideActions(request);\n\n    const serverSideActionsInput: ActionInput[] = serverSideActions.map((action) => ({\n      name: action.name,\n      description: action.description,\n      jsonSchema: JSON.stringify(actionParametersToJsonSchema(action.parameters)),\n    }));\n\n    const actionInputs = flattenToolCallsNoDuplicates([\n      ...serverSideActionsInput,\n      ...clientSideActionsInput,\n    ]);\n\n    await this.onBeforeRequest?.({\n      threadId,\n      runId,\n      inputMessages,\n      properties: graphqlContext.properties,\n      url,\n    });\n\n    try {\n      const eventSource = new RuntimeEventSource();\n\n      const result = await serviceAdapter.process({\n        messages: inputMessages,\n        actions: actionInputs,\n        threadId,\n        runId,\n        eventSource,\n        forwardedParameters,\n      });\n\n      outputMessagesPromise\n        .then((outputMessages) => {\n          this.onAfterRequest?.({\n            threadId: result.threadId,\n            runId: result.runId,\n            inputMessages,\n            outputMessages,\n            properties: graphqlContext.properties,\n            url,\n          });\n        })\n        .catch((_error) => {});\n\n      return {\n        threadId: result.threadId,\n        runId: result.runId,\n        eventSource,\n        serverSideActions,\n        actionInputsWithoutAgents: actionInputs.filter(\n          (action) =>\n            // TODO-AGENTS: do not exclude ALL server side actions\n            !serverSideActions.find((serverSideAction) => serverSideAction.name == action.name),\n          // !isLangGraphAgentAction(\n          //   serverSideActions.find((serverSideAction) => serverSideAction.name == action.name),\n          // ),\n        ),\n      };\n    } catch (error) {\n      console.error(\"Error getting response:\", error);\n      throw error;\n    }\n  }\n\n  private async processAgentRequest(\n    request: CopilotRuntimeRequest,\n  ): Promise<CopilotRuntimeResponse> {\n    const { messages: rawMessages, outputMessagesPromise, graphqlContext, agentSession } = request;\n    const { threadId = randomId(), agentName, nodeName } = agentSession;\n    const serverSideActions = await this.getServerSideActions(request);\n\n    const messages = convertGqlInputToMessages(rawMessages);\n\n    const agent = serverSideActions.find(\n      (action) => action.name === agentName && isLangGraphAgentAction(action),\n    ) as LangGraphAgentAction;\n\n    if (!agent) {\n      throw new Error(`Agent ${agentName} not found`);\n    }\n\n    const serverSideActionsInput: ActionInput[] = serverSideActions\n      .filter((action) => !isLangGraphAgentAction(action))\n      .map((action) => ({\n        name: action.name,\n        description: action.description,\n        jsonSchema: JSON.stringify(actionParametersToJsonSchema(action.parameters)),\n      }));\n\n    const actionInputsWithoutAgents = flattenToolCallsNoDuplicates([\n      ...serverSideActionsInput,\n      ...request.actions,\n    ]);\n\n    await this.onBeforeRequest?.({\n      threadId,\n      runId: undefined,\n      inputMessages: messages,\n      properties: graphqlContext.properties,\n    });\n    try {\n      const eventSource = new RuntimeEventSource();\n      const stream = await agent.langGraphAgentHandler({\n        name: agentName,\n        threadId,\n        nodeName,\n        actionInputsWithoutAgents,\n      });\n\n      eventSource.stream(async (eventStream$) => {\n        from(stream).subscribe({\n          next: (event) => eventStream$.next(event),\n          error: (err) => console.error(\"Error in stream\", err),\n          complete: () => eventStream$.complete(),\n        });\n      });\n\n      outputMessagesPromise\n        .then((outputMessages) => {\n          this.onAfterRequest?.({\n            threadId,\n            runId: undefined,\n            inputMessages: messages,\n            outputMessages,\n            properties: graphqlContext.properties,\n          });\n        })\n        .catch((_error) => {});\n\n      return {\n        threadId,\n        runId: undefined,\n        eventSource,\n        serverSideActions: [],\n        actionInputsWithoutAgents,\n      };\n    } catch (error) {\n      console.error(\"Error getting response:\", error);\n      throw error;\n    }\n  }\n\n  private async getServerSideActions(request: CopilotRuntimeRequest): Promise<Action<any>[]> {\n    const { messages: rawMessages, graphqlContext, agentStates, url } = request;\n    const inputMessages = convertGqlInputToMessages(rawMessages);\n    const langserveFunctions: Action<any>[] = [];\n\n    for (const chainPromise of this.langserve) {\n      try {\n        const chain = await chainPromise;\n        langserveFunctions.push(chain);\n      } catch (error) {\n        console.error(\"Error loading langserve chain:\", error);\n      }\n    }\n    const remoteActions = await setupRemoteActions({\n      remoteActionDefinitions: this.remoteActionDefinitions,\n      graphqlContext,\n      messages: inputMessages,\n      agentStates,\n      frontendUrl: url,\n    });\n\n    const configuredActions =\n      typeof this.actions === \"function\"\n        ? this.actions({ properties: graphqlContext.properties, url })\n        : this.actions;\n\n    return [...configuredActions, ...langserveFunctions, ...remoteActions];\n  }\n}\n\nexport function flattenToolCallsNoDuplicates(toolsByPriority: ActionInput[]): ActionInput[] {\n  let allTools: ActionInput[] = [];\n  const allToolNames: string[] = [];\n  for (const tool of toolsByPriority) {\n    if (!allToolNames.includes(tool.name)) {\n      allTools.push(tool);\n      allToolNames.push(tool.name);\n    }\n  }\n  return allTools;\n}\n","import {\n  ActionExecutionMessage,\n  Message,\n  ResultMessage,\n  TextMessage,\n  AgentStateMessage,\n} from \"../graphql/types/converted\";\nimport { MessageInput } from \"../graphql/inputs/message.input\";\nimport { plainToInstance } from \"class-transformer\";\n\nexport function convertGqlInputToMessages(inputMessages: MessageInput[]): Message[] {\n  const messages: Message[] = [];\n\n  for (const message of inputMessages) {\n    if (message.textMessage) {\n      messages.push(\n        plainToInstance(TextMessage, {\n          id: message.id,\n          createdAt: message.createdAt,\n          role: message.textMessage.role,\n          content: message.textMessage.content,\n        }),\n      );\n    } else if (message.actionExecutionMessage) {\n      messages.push(\n        plainToInstance(ActionExecutionMessage, {\n          id: message.id,\n          createdAt: message.createdAt,\n          name: message.actionExecutionMessage.name,\n          arguments: JSON.parse(message.actionExecutionMessage.arguments),\n          scope: message.actionExecutionMessage.scope,\n        }),\n      );\n    } else if (message.resultMessage) {\n      messages.push(\n        plainToInstance(ResultMessage, {\n          id: message.id,\n          createdAt: message.createdAt,\n          actionExecutionId: message.resultMessage.actionExecutionId,\n          actionName: message.resultMessage.actionName,\n          result: message.resultMessage.result,\n        }),\n      );\n    } else if (message.agentStateMessage) {\n      messages.push(\n        plainToInstance(AgentStateMessage, {\n          id: message.id,\n          threadId: message.agentStateMessage.threadId,\n          createdAt: message.createdAt,\n          agentName: message.agentStateMessage.agentName,\n          nodeName: message.agentStateMessage.nodeName,\n          runId: message.agentStateMessage.runId,\n          active: message.agentStateMessage.active,\n          role: message.agentStateMessage.role,\n          state: JSON.parse(message.agentStateMessage.state),\n          running: message.agentStateMessage.running,\n        }),\n      );\n    }\n  }\n\n  return messages;\n}\n"],"mappings":"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","names":["actionParametersToJsonSchema","randomId","plainToInstance","convertGqlInputToMessages","inputMessages","messages","message","textMessage","push","plainToInstance","TextMessage","id","createdAt","role","content","actionExecutionMessage","ActionExecutionMessage","name","arguments","JSON","parse","scope","resultMessage","ResultMessage","actionExecutionId","actionName","result","agentStateMessage","AgentStateMessage","threadId","agentName","nodeName","runId","active","state","running","from","CopilotRuntime","actions","remoteActionDefinitions","langserve","onBeforeRequest","onAfterRequest","constructor","params","chain","remoteChain","RemoteChain","push","toAction","remoteActions","middleware","processRuntimeRequest","request","serviceAdapter","messages","rawMessages","clientSideActionsInput","threadId","runId","outputMessagesPromise","graphqlContext","forwardedParameters","agentSession","url","processAgentRequest","filter","message","agentStateMessage","inputMessages","convertGqlInputToMessages","serverSideActions","getServerSideActions","serverSideActionsInput","map","action","name","description","jsonSchema","JSON","stringify","actionParametersToJsonSchema","parameters","actionInputs","flattenToolCallsNoDuplicates","properties","eventSource","RuntimeEventSource","result","process","then","outputMessages","_a","catch","_error","actionInputsWithoutAgents","find","serverSideAction","error","console","randomId","agentName","nodeName","agent","isLangGraphAgentAction","Error","undefined","stream","langGraphAgentHandler","eventStream$","from","subscribe","next","event","err","complete","agentStates","langserveFunctions","chainPromise","setupRemoteActions","frontendUrl","configuredActions","toolsByPriority","allTools","allToolNames","tool","includes"]}