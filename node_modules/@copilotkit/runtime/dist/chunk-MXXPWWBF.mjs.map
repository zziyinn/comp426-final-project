{"version":3,"sources":["../src/service-adapters/langchain/utils.ts"],"sourcesContent":["import {\n  ActionExecutionMessage,\n  Message,\n  ResultMessage,\n  TextMessage,\n} from \"../../graphql/types/converted\";\nimport {\n  AIMessage,\n  AIMessageChunk,\n  BaseMessage,\n  BaseMessageChunk,\n  HumanMessage,\n  SystemMessage,\n  ToolMessage,\n} from \"@langchain/core/messages\";\nimport { DynamicStructuredTool } from \"@langchain/core/tools\";\nimport { z } from \"zod\";\nimport { ActionInput } from \"../../graphql/inputs/action.input\";\nimport { LangChainReturnType } from \"./types\";\nimport { RuntimeEventSubject } from \"../events\";\nimport { randomId } from \"@copilotkit/shared\";\n\nexport function convertMessageToLangChainMessage(message: Message): BaseMessage {\n  if (message.isTextMessage()) {\n    if (message.role == \"user\") {\n      return new HumanMessage(message.content);\n    } else if (message.role == \"assistant\") {\n      return new AIMessage(message.content);\n    } else if (message.role === \"system\") {\n      return new SystemMessage(message.content);\n    }\n  } else if (message.isActionExecutionMessage()) {\n    return new AIMessage({\n      content: \"\",\n      tool_calls: [\n        {\n          id: message.id,\n          args: message.arguments,\n          name: message.name,\n        },\n      ],\n    });\n  } else if (message.isResultMessage()) {\n    return new ToolMessage({\n      content: message.result,\n      tool_call_id: message.actionExecutionId,\n    });\n  }\n}\n\nexport function convertJsonSchemaToZodSchema(jsonSchema: any, required: boolean): z.ZodSchema {\n  if (jsonSchema.type === \"object\") {\n    const spec: { [key: string]: z.ZodSchema } = {};\n\n    if (!jsonSchema.properties || !Object.keys(jsonSchema.properties).length) {\n      return !required ? z.object(spec).optional() : z.object(spec);\n    }\n\n    for (const [key, value] of Object.entries(jsonSchema.properties)) {\n      spec[key] = convertJsonSchemaToZodSchema(\n        value,\n        jsonSchema.required ? jsonSchema.required.includes(key) : false,\n      );\n    }\n    let schema = z.object(spec).describe(jsonSchema.description);\n    return required ? schema : schema.optional();\n  } else if (jsonSchema.type === \"string\") {\n    let schema = z.string().describe(jsonSchema.description);\n    return required ? schema : schema.optional();\n  } else if (jsonSchema.type === \"number\") {\n    let schema = z.number().describe(jsonSchema.description);\n    return required ? schema : schema.optional();\n  } else if (jsonSchema.type === \"boolean\") {\n    let schema = z.boolean().describe(jsonSchema.description);\n    return required ? schema : schema.optional();\n  } else if (jsonSchema.type === \"array\") {\n    let itemSchema = convertJsonSchemaToZodSchema(jsonSchema.items, true);\n    let schema = z.array(itemSchema).describe(jsonSchema.description);\n    return required ? schema : schema.optional();\n  }\n}\n\nexport function convertActionInputToLangChainTool(actionInput: ActionInput): any {\n  return new DynamicStructuredTool({\n    name: actionInput.name,\n    description: actionInput.description,\n    schema: convertJsonSchemaToZodSchema(\n      JSON.parse(actionInput.jsonSchema),\n      true,\n    ) as z.ZodObject<any>,\n    func: async () => {\n      return \"\";\n    },\n  });\n}\n\ninterface StreamLangChainResponseParams {\n  result: LangChainReturnType;\n  eventStream$: RuntimeEventSubject;\n  actionExecution?: {\n    id: string;\n    name: string;\n  };\n}\n\nfunction getConstructorName(object: any): string {\n  if (object && typeof object === \"object\" && object.constructor && object.constructor.name) {\n    return object.constructor.name;\n  }\n  return \"\";\n}\n\nfunction isAIMessage(message: any): message is AIMessage {\n  return Object.prototype.toString.call(message) === \"[object AIMessage]\";\n}\n\nfunction isAIMessageChunk(message: any): message is AIMessageChunk {\n  return Object.prototype.toString.call(message) === \"[object AIMessageChunk]\";\n}\n\nfunction isBaseMessageChunk(message: any): message is BaseMessageChunk {\n  return Object.prototype.toString.call(message) === \"[object BaseMessageChunk]\";\n}\n\nfunction maybeSendActionExecutionResultIsMessage(\n  eventStream$: RuntimeEventSubject,\n  actionExecution?: { id: string; name: string },\n) {\n  // language models need a result after the function call\n  // we simply let them know that we are sending a message\n  if (actionExecution) {\n    eventStream$.sendActionExecutionResult(\n      actionExecution.id,\n      actionExecution.name,\n      \"Sending a message\",\n    );\n  }\n}\n\nexport async function streamLangChainResponse({\n  result,\n  eventStream$,\n  actionExecution,\n}: StreamLangChainResponseParams) {\n  // We support several types of return values from LangChain functions:\n\n  // 1. string\n\n  if (typeof result === \"string\") {\n    if (!actionExecution) {\n      // Just send one chunk with the string as the content.\n      eventStream$.sendTextMessage(randomId(), result);\n    } else {\n      // Send as a result\n      eventStream$.sendActionExecutionResult(actionExecution.id, actionExecution.name, result);\n    }\n  }\n\n  // 2. AIMessage\n  // Send the content and function call of the AIMessage as the content of the chunk.\n  else if (isAIMessage(result)) {\n    maybeSendActionExecutionResultIsMessage(eventStream$, actionExecution);\n\n    if (result.content) {\n      eventStream$.sendTextMessage(randomId(), result.content as string);\n    }\n    for (const toolCall of result.tool_calls) {\n      eventStream$.sendActionExecution(\n        toolCall.id || randomId(),\n        toolCall.name,\n        JSON.stringify(toolCall.args),\n      );\n    }\n  }\n\n  // 3. BaseMessageChunk\n  // Send the content and function call of the AIMessage as the content of the chunk.\n  else if (isBaseMessageChunk(result)) {\n    maybeSendActionExecutionResultIsMessage(eventStream$, actionExecution);\n\n    if (result.lc_kwargs?.content) {\n      eventStream$.sendTextMessage(randomId(), result.content as string);\n    }\n    if (result.lc_kwargs?.tool_calls) {\n      for (const toolCall of result.lc_kwargs?.tool_calls) {\n        eventStream$.sendActionExecution(\n          toolCall.id || randomId(),\n          toolCall.name,\n          JSON.stringify(toolCall.args),\n        );\n      }\n    }\n  }\n\n  // 4. IterableReadableStream\n  // Stream the result of the LangChain function.\n  else if (result && \"getReader\" in result) {\n    maybeSendActionExecutionResultIsMessage(eventStream$, actionExecution);\n\n    let reader = result.getReader();\n\n    let mode: \"function\" | \"message\" | null = null;\n\n    const toolCallDetails = {\n      name: null,\n      id: null,\n      index: null,\n      prevIndex: null,\n    };\n\n    while (true) {\n      try {\n        const { done, value } = await reader.read();\n\n        let toolCallName: string | undefined = undefined;\n        let toolCallId: string | undefined = undefined;\n        let toolCallArgs: string | undefined = undefined;\n        let hasToolCall: boolean = false;\n        let content = value?.content as string;\n\n        if (isAIMessageChunk(value)) {\n          let chunk = value.tool_call_chunks?.[0];\n          toolCallArgs = chunk?.args;\n          hasToolCall = chunk != undefined;\n          if (chunk?.name) toolCallDetails.name = chunk.name;\n          // track different index on the same tool cool\n          if (chunk?.index != null) {\n            toolCallDetails.index = chunk.index; // 1\n            if (toolCallDetails.prevIndex == null) toolCallDetails.prevIndex = chunk.index;\n          }\n          // Differentiate when calling the same tool but with different index\n          if (chunk?.id)\n            toolCallDetails.id = chunk.index != null ? `${chunk.id}-idx-${chunk.index}` : chunk.id;\n\n          // Assign to internal variables that the entire script here knows how to work with\n          toolCallName = toolCallDetails.name;\n          toolCallId = toolCallDetails.id;\n        } else if (isBaseMessageChunk(value)) {\n          let chunk = value.additional_kwargs?.tool_calls?.[0];\n          toolCallName = chunk?.function?.name;\n          toolCallId = chunk?.id;\n          toolCallArgs = chunk?.function?.arguments;\n          hasToolCall = chunk?.function != undefined;\n        }\n\n        // When switching from message to function or vice versa,\n        // send the respective end event.\n        // If toolCallName is defined, it means a new tool call starts.\n        if (mode === \"message\" && (toolCallId || done)) {\n          mode = null;\n          eventStream$.sendTextMessageEnd();\n        } else if (mode === \"function\" && (!hasToolCall || done)) {\n          mode = null;\n          eventStream$.sendActionExecutionEnd();\n        }\n\n        if (done) {\n          break;\n        }\n\n        // If we send a new message type, send the appropriate start event.\n        if (mode === null) {\n          if (hasToolCall && toolCallId && toolCallName) {\n            mode = \"function\";\n            eventStream$.sendActionExecutionStart(toolCallId, toolCallName);\n          } else if (content) {\n            mode = \"message\";\n            eventStream$.sendTextMessageStart(randomId());\n          }\n        }\n\n        // send the content events\n        if (mode === \"message\" && content) {\n          eventStream$.sendTextMessageContent(\n            Array.isArray(content) ? (content[0]?.text ?? \"\") : content,\n          );\n        } else if (mode === \"function\" && toolCallArgs) {\n          // For calls of the same tool with different index, we seal last tool call and register a new one\n          if (toolCallDetails.index !== toolCallDetails.prevIndex) {\n            eventStream$.sendActionExecutionEnd();\n            eventStream$.sendActionExecutionStart(toolCallId, toolCallName);\n            toolCallDetails.prevIndex = toolCallDetails.index;\n          }\n          eventStream$.sendActionExecutionArgs(toolCallArgs);\n        }\n      } catch (error) {\n        console.error(\"Error reading from stream\", error);\n        break;\n      }\n    }\n  } else if (actionExecution) {\n    eventStream$.sendActionExecutionResult(\n      actionExecution.id,\n      actionExecution.name,\n      encodeResult(result),\n    );\n  }\n\n  // unsupported type\n  else {\n    throw new Error(\"Invalid return type from LangChain function.\");\n  }\n\n  eventStream$.complete();\n}\n\nfunction encodeResult(result: any): string {\n  if (result === undefined) {\n    return \"\";\n  } else if (typeof result === \"string\") {\n    return result;\n  } else {\n    return JSON.stringify(result);\n  }\n}\n"],"mappings":"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","names":["AIMessage","HumanMessage","SystemMessage","ToolMessage","DynamicStructuredTool","z","randomId","convertMessageToLangChainMessage","message","isTextMessage","role","HumanMessage","content","AIMessage","SystemMessage","isActionExecutionMessage","tool_calls","id","args","arguments","name","isResultMessage","ToolMessage","result","tool_call_id","actionExecutionId","convertJsonSchemaToZodSchema","jsonSchema","required","type","spec","properties","Object","keys","length","z","object","optional","key","value","entries","includes","schema","describe","description","string","number","boolean","itemSchema","items","array","convertActionInputToLangChainTool","actionInput","DynamicStructuredTool","JSON","parse","func","isAIMessage","message","Object","prototype","toString","call","isAIMessageChunk","isBaseMessageChunk","maybeSendActionExecutionResultIsMessage","eventStream$","actionExecution","sendActionExecutionResult","id","name","streamLangChainResponse","result","sendTextMessage","randomId","content","toolCall","tool_calls","sendActionExecution","JSON","stringify","args","lc_kwargs","reader","getReader","mode","toolCallDetails","index","prevIndex","done","value","read","toolCallName","undefined","toolCallId","toolCallArgs","hasToolCall","chunk","tool_call_chunks","additional_kwargs","function","arguments","sendTextMessageEnd","sendActionExecutionEnd","sendActionExecutionStart","sendTextMessageStart","sendTextMessageContent","Array","isArray","text","sendActionExecutionArgs","error","console","encodeResult","Error","complete"]}