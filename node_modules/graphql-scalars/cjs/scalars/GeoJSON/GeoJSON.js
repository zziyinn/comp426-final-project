"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GraphQLGeoJSON = void 0;
const graphql_1 = require("graphql");
const error_js_1 = require("../../error.js");
const codegenScalarType_js_1 = require("./codegenScalarType.js");
const jsonSchema_js_1 = require("./jsonSchema.js");
const validators_js_1 = require("./validators.js");
const validate = (value, ast) => {
    let parsed;
    if (typeof value === 'string') {
        try {
            parsed = JSON.parse(value);
        }
        catch (_a) {
            throw (0, error_js_1.createGraphQLError)('Invalid GeoJSON: Failed to parse JSON string', ast ? { nodes: ast } : undefined);
        }
    }
    else {
        parsed = value;
    }
    if (!parsed || typeof parsed !== 'object') {
        throw (0, error_js_1.createGraphQLError)('Invalid GeoJSON: Must be an object', ast ? { nodes: ast } : undefined);
    }
    if (!('type' in parsed)) {
        throw (0, error_js_1.createGraphQLError)('Invalid GeoJSON: Missing type property', ast ? { nodes: ast } : undefined);
    }
    // Validate bbox if present
    if ('bbox' in parsed && parsed.bbox !== undefined) {
        if (!(0, validators_js_1.isValidBBox)(parsed.bbox)) {
            throw (0, error_js_1.createGraphQLError)('Invalid GeoJSON: Invalid bbox format', ast ? { nodes: ast } : undefined);
        }
    }
    // Validate based on type
    /*if (parsed.type === 'Feature') {
      if (!isValidFeature(parsed)) {
        throw createGraphQLError(
          'Invalid GeoJSON: Invalid Feature object',
          ast ? { nodes: ast } : undefined,
        );
      }
    } else if (parsed.type === 'FeatureCollection') {
      if (!isValidFeatureCollection(parsed)) {
        throw createGraphQLError(
          'Invalid GeoJSON: Invalid FeatureCollection object',
          ast ? { nodes: ast } : undefined,
        );
      }
    } else if (!isValidGeometry(parsed)) {
      throw createGraphQLError(
        'Invalid GeoJSON: Invalid Geometry object',
        ast ? { nodes: ast } : undefined,
      );
    }*/
    if ((0, validators_js_1.isValidFeature)(parsed)) {
        return parsed;
    }
    else if ((0, validators_js_1.isValidFeatureCollection)(parsed)) {
        return parsed;
    }
    else if ((0, validators_js_1.isValidGeometry)(parsed)) {
        return parsed;
    }
    // return parsed as GeoJSONObject;
    throw (0, error_js_1.createGraphQLError)('Invalid GeoJSON: Object does not match any valid GeoJSON type', ast ? { nodes: ast } : undefined);
};
exports.GraphQLGeoJSON = new graphql_1.GraphQLScalarType({
    name: 'GeoJSON',
    description: 'A GeoJSON object as defined by RFC 7946: https://datatracker.ietf.org/doc/html/rfc7946',
    serialize(value) {
        return validate(value);
    },
    parseValue(value) {
        return validate(value);
    },
    parseLiteral(ast) {
        if (ast.kind !== graphql_1.Kind.STRING && ast.kind !== graphql_1.Kind.OBJECT) {
            throw (0, error_js_1.createGraphQLError)(`Can only validate strings or objects as GeoJSON but got a: ${ast.kind}`, { nodes: [ast] });
        }
        return validate(ast.kind === graphql_1.Kind.STRING ? ast.value : ast, ast);
    },
    extensions: {
        codegenScalarType: (0, codegenScalarType_js_1.generateGeoJSONType)(),
        jsonSchema: jsonSchema_js_1.geojsonSchema,
    },
});
